#+Title: Clojure Emacs Generation File
#+AUTHOR: Tory S. Anderson

* emacs.el
** Preamble
Here we establish load path and default settings before we will use =use-package=.

#+BEGIN_SRC elisp :tangle emacs.el
 ;;; .emacs.el  --- Emacs Init File -S*- lexical-binding: t -*-
;;; THIS FILE IS GENERATED
#+END_SRC

Follow Symlinks without prompting, so Git doesn't have issues with my setup
#+BEGIN_SRC elisp :tangle emacs.el
 (setq vc-follow-symlinks t)
#+END_SRC

#+BEGIN_SRC elisp :tangle emacs.el
  (setq user-emacs-directory "~/emacs/.emacs.d/")
  
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
** misc vars
Set search to look for spaces literally
#+BEGIN_SRC elisp :tangle emacs.el
  (setq isearch-lax-whitespace nil)
  (defalias 'yes-or-no-p 'y-or-n-p) ; stop asking "yes" http://www.emacswiki.org/emacs/YesOrNoP
  (add-to-list 'auto-mode-alist '("\\.service\\'" . conf-mode))
  (add-to-list 'auto-mode-alist '("\\.path\\'" . conf-mode))
#+END_SRC

** Init w/ straight.el
   #+begin_src elisp :tangle emacs.el
(setq straight-cache-autoloads t
      straight-check-for-modifications '(check-on-save find-when-checking)
      straight-repository-branch "develop"
      straight-use-package-by-default t
      use-package-always-ensure nil)

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)

;; https://github.com/raxod502/straight.el/issues/49#issuecomment-395979478
(defun straight-x-clean-unused-repos ()
  (interactive)
  (dolist (repo (straight--directory-files (straight--repos-dir)))
    (unless (or (straight--checkhash repo straight--repo-cache)
                (not (y-or-n-p (format "Delete repository %S?" repo))))
      (delete-directory (straight--repos-dir repo) 'recursive 'trash))))
#+end_src

** Disabled commmands
These "put" commands don't have versions within customize-variables  
  #+BEGIN_SRC elisp :tangle emacs.el
    (setq browse-pdf-generic-program (executable-find "emacsclient"))
    (put 'list-timers 'disabled nil)
    (put 'scroll-left 'disabled nil)
    (put 'narrow-to-region 'disabled nil)
    (put 'narrow-to-page 'disabled nil)
    (put 'downcase-region 'disabled nil)
    (put 'upcase-region 'disabled nil)
#+END_SRC

** Global customizations EMACS
Customizations not paired to a particular package
#+begin_src elisp :tangle emacs.el
  (use-package emacs
    :straight (:type built-in)
    :init
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
    :custom
    (backup-directory-alist '((".*" . "~/emacs/.emacs.d/temporary_files")))
    (blink-cursor-blinks 0)
    (blink-cursor-mode t)
    (case-fold-search t)
    (create-lockfiles nil)
    (cua-global-mark-cursor-color "#2aa198")
    (cua-normal-cursor-color "#839496")
    (cua-overwrite-cursor-color "#b58900")
    (cua-read-only-cursor-color "#859900")
    (custom-safe-themes t)
    (current-language-environment "UTF-8")
    (truncate-lines nil)
    (debug-on-error nil)
    (debug-on-quit nil)
    (delete-old-versions t)
    (electric-pair-mode nil)
    (enable-local-variables t)
    (fill-column 9999)
    (frame-background-mode 'dark)
    (global-hl-line-mode t)
    (global-linum-mode t)
    (help-at-pt-display-when-idle '(flymake-diagnostic) nil (help-at-pt))
    (help-at-pt-timer-delay 1)
    (history-delete-duplicates t)
    (hl-bg-colors
     '("#7B6000" "#8B2C02" "#990A1B" "#93115C" "#3F4D91" "#00629D" "#00736F" "#546E00"))
    (hl-fg-colors
     '("#002b36" "#002b36" "#002b36" "#002b36" "#002b36" "#002b36" "#002b36" "#002b36"))
    (hl-paren-colors '("#B9F" "#B8D" "#B7B" "#B69" "#B57" "#B45" "#B33" "#B11"))
    (hl-sexp-background-color "#efebe9")
    (hscroll-margin 30)
    (hscroll-step 3)
    (inhibit-startup-screen t)
    (initial-scratch-message "")
    (large-file-warning-threshold nil)
    (line-number-mode t)
    (mark-even-if-inactive t)
    (max-lisp-eval-depth 9000)
    (max-mini-window-height 1.0)
    (max-specpdl-size 10000)
    (minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))  
    (password-cache-expiry 3600)
    (pos-tip-background-color "#073642")
    (pos-tip-foreground-color "#93a1a1")
    (recentf-auto-cleanup 'mode)
    (recentf-max-menu-items 100)
    (recentf-max-saved-items 100)
    (resize-mini-windows nil)
    (save-interprogram-paste-before-kill t)
    (scroll-bar-mode nil)
    (scroll-step 2)
    (mouse-wheel-progressive-speed nil)
    (mouse-wheel-follow-mouse t)
    (temporary-file-directory "~/emacs/.emacs.d/temporary_files")
    (truncate-partial-width-windows nil)
    (view-read-only t)
    (visible-bell t)
    (window-divider-default-bottom-width 1 nil nil "Customized with use-package window-divider")
    (window-divider-default-places t nil nil "Customized with use-package window-divider")
    (window-divider-default-right-width 1 nil nil "Customized with use-package window-divider")
    (window-divider-mode t)
    (word-wrap t)
  
  ;;;;;;;;;;;;;;;;;;;;;;
    :custom-face
    (default ((t (:inherit nil :extend nil :stipple nil :inverse-video nil :box nil :strike-through nil :overline nil :underline nil :slant normal :weight normal :height 150 :width normal :foundry "ADBO" :family "Source Code Pro"))))
    (cursor ((t (:background "orange red"))))
    (display-time-mail-face ((t (:background "red" :foreground "deep sky blue" :box (:line-width 2 :color "grey75" :style released-button)))))
					  ;      (helm-selection ((t (:inherit bold :extend t :background "#4169e1" :foreground "black"))))
    (hl-line ((t (:extend t :background "#191970"))))
    (mode-line-buffer-id ((t (:foreground "white smoke" :background "midnight blue"))))
    (mode-line ((t (:background "gray4" :foreground "light sky blue"))))
    (mode-line-inactive ((t (:background "#696969" :foreground "black" :box nil))))
    (popup-scroll-bar-background-face ((t (:background "black"))))
    (popup-scroll-bar-foreground-face ((t (:background "red"))))
    (scroll-bar ((t (:background "DarkRed" :foreground "black"))))
    (show-paren-match ((t (:background "#Ff4500" :foreground "black" :weight ultra-bold))))
    (window-divider ((t (:inherit vertical-border :background "cyan" :foreground "cyan" :width normal))))
  
    :config
    (global-hl-line-mode t)
    (global-auto-revert-mode t)
    ) ;; use-package emacs
#+end_src

** [#A] All Packages
Using the straight-use-package macro to provide use-package functionality

*** anzu-mode
    See-as-you-go query-replace. 
https://github.com/emacsorphanage/anzu
 Incremental query-replace.
 #+BEGIN_SRC elisp :tangle emacs.el
       (use-package anzu
	 :delight
	 :config (global-anzu-mode 1)
	 (setq anzu-minimum-input-length 4))
 #+END_SRC
*** better-shell
    https://github.com/killdash9/better-shell
    Ties in with Hydra binds for shell management
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package better-shell
    :commands (tsa/hydra-shells shell better-shell-shell))
#+END_SRC

*** Bookmark+
     Bookmark+ is one of those must-have packages.

 #+BEGIN_SRC elisp :tangle emacs.el     
   (use-package bookmark+
       :straight (bookmark+ :type git :host github :repo "emacsmirror/bookmark-plus")
       :demand t
       :custom
       (bmkp-last-as-first-bookmark-file "~/emacs/.emacs.d/bookmarks")
       (bookmark-save-flag 0)
       (bmkp-prompt-for-tags-flag nil)
       (bookmark-version-control t)
       (bmkp-default-handlers-for-file-types 
	     '(("\\.pdf$" . find-file)
	       ("\\.html$" . browse-url)
	       ("^http" . browse-url)))
       :custom-face
      (bmkp-a-mark ((t (:background "cyan" :foreground "black"))))
      (bmkp-file-handler ((t (:background "#FF8080" :foreground "black"))))

       :config    
       (defadvice bookmark-jump (after bookmark-jump activate)
	 (let ((latest (bookmark-get-bookmark bookmark)))
	   (setq bookmark-alist (delq latest bookmark-alist))
	   (add-to-list 'bookmark-alist latest)))
       )
 #+END_SRC

*** Buffer management
**** Vertico Family
https://github.com/minad/vertico

***** use-package vertico
#+begin_src elisp :tangle emacs.el
(use-package vertico
  :init
  (vertico-mode)

  ;; Optionally enable cycling for `vertico-next', `vertico-previous',
  ;; `vertico-next-group' and `vertico-previous-group'.
  ;; (setq vertico-cycle t)
)
#+end_src

***** Savehist
https://www.emacswiki.org/emacs/SaveHist
Recommended by Vertico. May work like prescient? 

#+begin_src elisp :tangle emacs.el
  (use-package savehist
    :straight (:type built-in)
    :init
    (savehist-mode))
#+end_src
**** Orderless
Recommended by Vertico
#+begin_src elisp :tangle emacs.el
(use-package orderless
  :init
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src
**** Consult
https://github.com/minad/consult

#+begin_src elisp :tangle emacs.el
  (use-package consult
    :straight (consult :type git :host github :repo "minad/consult")
    :demand t
    :bind (("C-c s" . consult-outline)
	   ("C-x j j" . consult-bookmark)
	   ("M-s l" . consult-line)
	   ("C-h k" . tsa/consult-descbinds)
	   ("M-y" . consult-yank-pop)
	   ("<help> a" . consult-apropos))
    ;; :custom
    ;; (consult-project-root-function 'projectile-project-root)
    ;; (consult--read-config `((consult-bookmark :preview-key nil)
    ;; 			  (consult-buffer :preview-key ,(kbd "M-p"))))
    :config
    (consult-customize
     consult-bookmark :preview-key nil
     consult-buffer :preview-key (kbd "M-p"))
    (fset 'multi-occur #'consult-multi-occur))
    #+end_src
    
***** Consult-from-isearch
#+begin_src elisp :tangle emacs.el
(defun consult-line-from-isearch ()
   (interactive)
   (consult-line isearch-string))
#+end_src

***** Consult descbinds
    #+begin_src elisp :tangle emacs.el
(defun tsa/consult-descbinds ()
  (interactive)
  (describe-bindings)
  (other-window 1)
  (call-interactively #'consult-focus-lines))

#+end_src

**** bufler
https://github.com/alphapapa/bufler.el
I like this for the buffer-list, though not for switch-buffer. 

Note that =C-x C-b= will show only buffers in the currently focused group; if you U it with =C-u C-x C-b= you will see all buffers.

For my Firefox buffler to display, I need global =(case-fold-search t)=

 #+BEGIN_SRC elisp :tangle emacs.el
   (use-package bufler
     :delight '(:eval (if bufler-workspace-mode (concat "[buf:-" bufler-workspace-name "]") ""))
     :bind (("C-x C-b" . bufler)
	    :map bufler-list-mode-map
	    ("G" . tramp-cleanup-all-buffers))
     :custom (bufler-columns '("Name" "Size" "Path"))
     (bufler-column-name-max-length 30)
     :custom-face
     (bufler-buffer-special ((t (:inherit default :foreground "aqua" :slant italic))))
     :config
					   ;(bufler-mode t)
     (setf bufler-groups
	   (bufler-defgroups
	     (group
	      ;; Subgroup collecting all named workspaces.
	      (auto-workspace))
	     (group
	      (mode-match "*w3m*" (rx "w3m")))
	     (group
	      (mode-match "*EXWM*" (rx bos "EXWM"))
	      (name-match "(Private) *Firefox*" (rx "(Private Browsing)" eos))
	      (name-match "*Firefox*" (rx bos "F :"))           
	      )
	     (group
	      (group-or "Chat"
			(mode-match "Telega" (rx bos "telega-"))))
	     (group
	      ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
	      (group-or "*Help/Info*"
			(mode-match "*Help*" (rx bos "help-"))
			(mode-match "*Info*" (rx bos "info-"))))
	     (group
	      ;; Subgroup collecting all special buffers (i.e. ones that are not
	      ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
	      ;; through to other groups, so they end up grouped with their project buffers).
	      (group-and "*Special*"
			 (lambda (buffer)
			   (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
						buffer)
				       (funcall (mode-match "Dired" (rx bos "dired"))
						buffer)
				       (funcall (auto-file) buffer))
			     "*Special*")))
	      (group
	       ;; Subgroup collecting these "special special" buffers
	       ;; separately for convenience.
	       (name-match "**Special**"
			   (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace") "*")))
	      (group
	       ;; Subgroup collecting all other Magit buffers, grouped by directory.
	       (mode-match "*Magit* (non-status)" (rx bos (or "magit" "forge") "-"))
	       (auto-directory))
	      ;; Remaining special buffers are grouped automatically by mode.
	      (auto-mode))
	     ;; All buffers under "~/.emacs.d" (or wherever it is).
	     (dir user-emacs-directory)
	     (group
	      ;; Subgroup collecting buffers in `org-directory' (or "~/org" if
	      ;; `org-directory' is not yet defined).
	      (dir (if (bound-and-true-p org-directory)
		       org-directory
		     "~/org"))
	      (group
	       ;; Subgroup collecting indirect Org buffers, grouping them by file.
	       ;; This is very useful when used with `org-tree-to-indirect-buffer'.
	       (auto-indirect)
	       (auto-file))
	      ;; Group remaining buffers by whether they're file backed, then by mode.
	      (group-not "*special*" (auto-file))
	      (auto-mode))
	     (group
	      ;; Subgroup collecting buffers in a projectile project.
	      (auto-projectile))
	     (group
	      ;; Subgroup collecting buffers in a version-control project,
	      ;; grouping them by directory.
	      (auto-project))
	     ;; Group remaining buffers by directory, then major mode.
	     (auto-directory)
	     (auto-mode))))
#+END_SRC
**** [[https://github.com/jrosdahl/iflipb][iflipb]]
=m-TAB= functionality

#+BEGIN_SRC elisp :tangle emacs.el
  (use-package iflipb
    :bind ((("M-TAB" . iflipb-next-buffer))
	   ("M-S-TAB" . iflipb-previous-buffer))
    :custom
    (iflipb-ignore-buffers nil)
    (iflipb-permissive-flip-back t))
#+END_SRC
**** Marginalia
https://github.com/minad/marginalia
#+begin_src elisp :tangle emacs.el
  (use-package marginalia
    :straight (marginalia :type git :host github :repo "minad/marginalia")
    :bind (:map minibuffer-local-map
		("C-M-a" . marginalia-cycle)
		;; When using the Embark package, you can bind `marginalia-cycle' as an Embark action!
		;;:map embark-general-map
		;;     ("A" . marginalia-cycle)
		)
    :init
    (marginalia-mode)
    ;; When using Selectrum, ensure that Selectrum is refreshed when cycling annotations.
    ;; (advice-add #'marginalia-cycle :after
    ;; 	      (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit))))

    ;(setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    )
#+end_src

**** Embark
#+begin_src elisp :tangle emacs.el
  (use-package embark
    :straight (embark :type git :host github :repo "oantolin/embark")
    :bind
    (("M-." . embark-dwim)
     ("C-h B" . embark-bindings)
     ("C-." . embark-act))               ; pick some comfortable binding
    
    :config
    (setq embark-action-indicator
	  (lambda (map _target)
	    (which-key--show-keymap "Embark" map nil nil 'no-paging)
	    #'which-key--hide-popup-ignore-command)
	  embark-become-indicator embark-action-indicator)

    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))
#+end_src

***** Consult Embark
#+begin_src elisp :tangle emacs.el
  (use-package embark-consult
    :after (embark consult)
    :demand t ; only necessary if you have the hook below
    ;; if you want to have consult previews as you move around an
    ;; auto-updating embark collect buffer
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** LSP
https://emacs-lsp.github.io/lsp-mode/tutorials/clojure-guide/
      #+begin_src elisp :tangle emacs.el
	(use-package lsp-mode
	  :hook
	  (clojure-mode . lsp)
	  (clojurescript-mode . lsp)
	  (clojurec-mode . lsp)
	
	  :custom
	  (help-at-pt-timer-delay 1)
	  (help-at-pt-display-when-idle '(flymake-diagnostic))
	  (lsp-lens-enable t)
	  (lsp-signature-auto-activate nil)
	  :commands lsp)
        #+end_src

**** lsp-ui        
        #+begin_src elisp :tangle emacs.el
	  (use-package lsp-ui  :commands lsp-ui-mode)
          #+end_src

**** company-lsp          
          #+begin_src elisp :tangle emacs.el
	  (use-package company-lsp  :commands company-lsp)
      #+end_src

**** cider
 #+BEGIN_SRC elisp :tangle emacs.el
   (use-package cider
     :bind (:map cider-mode-map
		 ("C-c M-;" . cider-pprint-eval-last-sexp-to-comment)
		 ("C-c TAB" . clojure-align))
     :custom
     (cider-inject-dependencies-at-jack-in t)
     :config
     (setq cider-repl-use-clojure-font-lock t
	   cider-font-lock-dynamically '(macro core function var)
	   cider-default-cljs-repl 'figwheel
	   cider-repl-display-help-banner nil
	   cider-repl-use-pretty-printing t)
     (fset 'tsa/clojure-letvar-to-def
	   (lambda (&optional arg)
	     "with cursor at a let-var, def it so you can proceed with repl debugging." 
	     (interactive "p") (kmacro-exec-ring-item (quote ([40 100 101 102 32 C-right C-right 134217734 134217734 134217734 24 5 67108911 67108911] 0 "%d")) arg)))
     (define-key clojure-mode-map (kbd "M-L") 'tsa/clojure-letvar-to-def))
#+END_SRC

**** flycheck-joker
    #+begin_src  elisp :tangle emacs.el
    (use-package flycheck-joker)
    #+end_src

*** Clojure
**** clojure-mode
#+BEGIN_SRC elisp :tangle emacs.el
    (use-package clojure-mode
      :after flycheck-joker
      :hook  ((clojure-mode . my-clojure-mode-hook)
	      (clojure-mode . flycheck-mode))
    :custom
      (nrepl-message-colors
       '("#dc322f" "#cb4b16" "#b58900" "#546E00" "#B4C342" "#00629D" "#2aa198" "#d33682" "#6c71c4"))
    
      :custom-face 
      (clj-todo-face ((t (:box (:line-width 2 :color "dim gray" :style released-button) :weight ultra-bold))))
    
      :config
      (cider-auto-test-mode t)
      (defun my-clojure-mode-hook () 
	(highlight-phrase "TODO" 'clj-todo-face)
	(yas-minor-mode 1) 
	(cljr-add-keybindings-with-prefix "C-c C-m")
	(and buffer-file-name
	 (string-match "/\\(?:style\\|css\\)/" buffer-file-name)
	 (rainbow-mode 1)))
      (use-package flycheck-clj-kondo 
	:config
	(dolist (checkers '((clj-kondo-clj . clojure-joker)
			    (clj-kondo-cljs . clojurescript-joker)
			    (clj-kondo-cljc . clojure-joker)))
	  (flycheck-add-next-checker (car checkers) (cons 'error (cdr checkers))))))
#+END_SRC

**** clojure-mode font-locking
     Better display
#+BEGIN_SRC elisp :tangle emacs.el
   (use-package clojure-mode-extra-font-locking
     :requires clojure-mode)
#+END_SRC

**** COMMENT clj-refactor
 Sometimes leads to load errors with cider. 
 #+BEGIN_SRC elisp :tangle emacs.el     
   (use-package clj-refactor
     :after cider)
 #+END_SRC

*** company auto-complete
https://company-mode.github.io/

#+BEGIN_SRC elisp :tangle emacs.el
  (use-package company
       :delight company-mode
       :custom
       (company-quickhelp-color-background "#4F4F4F")
       (company-quickhelp-color-foreground "#DCDCCC")
       (company-idle-delay 0.3)
       :defer t
       :config
       (global-company-mode)
       (add-hook 'prog-mode-hook #'company-mode-on)       
       (setq company-idle-delay 0.3))

  (use-package company-quickhelp
       :demand t
       :config
       (company-quickhelp-mode 1)
       (setq company-quickhelp-delay 0.5)
       (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode)))
   #+END_SRC
   
*** dired family
    Workhorse dir-navigation. Refer to [[https://github.com/Fuco1/dired-hacks][dired hacks]] and [[https://www.emacswiki.org/emacs/DiredPlus][dired+]]
**** dired
#+begin_src elisp :tangle emacs.el
  (use-package dired
    :straight (:type built-in)
    :custom
    (dired-dwim-target t)
    (dired-guess-shell-alist-user '(("\\.*$" "xdg-open")))
    (dired-listing-switches "-alh")
    (diredp-image-preview-in-tooltip 300)
    :config
    (add-hook 'dired-mode-hook (lambda () (auto-revert-mode)))
  )
#+end_src

**** dired+
     Inimitable Drew Adams. 
 #+BEGIN_SRC elisp :tangle emacs.el
   (use-package dired+     
     :custom
     (dired-listing-switches "-alh")
     (delete-by-moving-to-trash t)
     :bind (:map dired-mode-map 
		 ("C-c C-r" . dired-toggle-read-only))
     :config
     (add-hook 'dired-mode-hook
	       (lambda ()
		 (define-key dired-mode-map (kbd "<return>")
		   'dired-find-alternate-file) ; was dired-advertised-find-file
		 (define-key dired-mode-map (kbd "^")
		   (lambda () (interactive) (find-alternate-file "..")))
					   ; was dired-up-directory
		 ))
     (setq dired-guess-shell-alist-user
	   (list (list "\\.*$" "xdg-open");; fixed rule
	  ;; possibly more rules...
		 ))
     (put 'dired-find-alternate-file 'disabled nil))
#+END_SRC
**** dired fixups 
settings, advanced sorting. 
#+begin_src  elisp :tangle emacs.el
(defun dired-sort-toggle ()
  "This is a redefinition of the fn from dired.el. Normally,
dired sorts on either name or time, and you can swap between them
with the s key.  This function one sets sorting on name, size,
time, and extension. Cycling works the same.
"
  (setq dired-actual-switches
        (let (case-fold-search)
          (cond
           ((string-match " " dired-actual-switches) ;; contains a space
            ;; New toggle scheme: add/remove a trailing " -t" " -S",
            ;; or " -U"
            ;; -t = sort by time (date)
            ;; -S = sort by size
            ;; -X = sort by extension

            (cond

             ((string-match " -t\\'" dired-actual-switches)
              (concat
               (substring dired-actual-switches 0 (match-beginning 0))
               " -X"))

             ((string-match " -X\\'" dired-actual-switches)
              (concat
               (substring dired-actual-switches 0 (match-beginning 0))
               " -S"))

             ((string-match " -S\\'" dired-actual-switches)
              (substring dired-actual-switches 0 (match-beginning 0)))

             (t
              (concat dired-actual-switches " -t"))))

           (t
            ;; old toggle scheme: look for a sorting switch, one of [tUXS]
            ;; and switch between them. Assume there is only ONE present.
            (let* ((old-sorting-switch
                    (if (string-match (concat "[t" dired-ls-sorting-switches "]")
                                      dired-actual-switches)
                        (substring dired-actual-switches (match-beginning 0)
                                   (match-end 0))
                      ""))

                   (new-sorting-switch
                    (cond
                     ((string= old-sorting-switch "t") "X")
                     ((string= old-sorting-switch "X") "S")
                     ((string= old-sorting-switch "S") "")
                     (t "t"))))
              (concat
               "-l"
               ;; strip -l and any sorting switches
               (dired-replace-in-string (concat "[-lt"
                                                dired-ls-sorting-switches "]")
                                        ""
                                        dired-actual-switches)
               new-sorting-switch))))))

  (dired-sort-set-modeline)
  (revert-buffer))

(defun dired-sort-set-modeline ()
 "This is a redefinition of the fn from `dired.el'. This one
properly provides the modeline in dired mode, supporting the new
search modes defined in the new `dired-sort-toggle'.
"
  ;; Set modeline display according to dired-actual-switches.
  ;; Modeline display of "by name" or "by date" guarantees the user a
  ;; match with the corresponding regexps.  Non-matching switches are
  ;; shown literally.
  (when (eq major-mode 'dired-mode)
    (setq mode-name
          (let (case-fold-search)
            (cond ((string-match "^-[^t]*t[^t]*$" dired-actual-switches)
                   "Dired by time")
                  ((string-match "^-[^X]*X[^X]*$" dired-actual-switches)
                   "Dired by ext")
                  ((string-match "^-[^S]*S[^S]*$" dired-actual-switches)
                   "Dired by sz")
                  ((string-match "^-[^SXUt]*$" dired-actual-switches)
                   "Dired by name")
                  (t
                   (concat "Dired " dired-actual-switches)))))
    (force-mode-line-update)))
#+end_src

**** diredfl for color
Trying to ensure chmod coloring
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package diredfl
    :demand t
    :config
    (add-hook 'dired-mode-hook 'diredfl-mode)
    :custom-face
    (diredfl-dir-name ((t (:foreground "#3679D8" :box (:line-width 2 :color "grey75" :style released-button)))))
    (diredfl-dir-priv ((t (:foreground "#3679D8" :underline t))))
    (diredfl-exec-priv ((t (:background "#79D836" :foreground "black"))))
    (diredfl-read-priv ((t (:background "#D8B941" :foreground "black"))))
    (diredfl-write-priv ((t (:background "#D83441" :foreground "black")))))
#+END_SRC
**** Dired Rainbow
#+BEGIN_SRC elisp :tangle emacs.el
(use-package dired-rainbow 
:custom-face
      (dired-rainbow-directory-face ((t (:foreground "#6cb2eb" :box (:line-width 2 :color "deep sky blue" :style released-button)))))
:config
  (progn
    (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
    (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
    (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
    (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
    (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
    (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
    (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
    (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
    (dired-rainbow-define log "#c17d11" ("log"))
    (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
    (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
    (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
    (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
    (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
    (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
    (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
    (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
    (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
    (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
    (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*")
    ))
#+END_SRC

**** dired-filter
     https://github.com/Fuco1/dired-hacks#dired-filter
#+BEGIN_SRC elisp :tangle emacs.el
    ;; Ibuffer-style filtering and saved filter groups (persistent, unlike narrow)
    (use-package dired-filter)
#+END_SRC

**** dired-narrow
     https://github.com/Fuco1/dired-hacks#dired-narrow
     Live filtering of dired
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package dired-narrow
    :bind
    (:map dired-mode-map
	  ("C-c n" . dired-narrow)))
#+END_SRC

*** COMMENT easy-kill
https://github.com/leoliu/easy-kill
Kill things smartly without worrying about the region. Replaces =M-w= and supplements with smart options.

See also expand-region. 

#+begin_quote
    M-w w: save word at point
    M-w s: save sexp at point
    M-w l: save list at point (enclosing sexp)
    M-w d: save defun at point
    M-w D: save current defun name
    M-w f: save file at point
    M-w b: save buffer-file-name or default-directory. - changes the kill to the directory name, + to full name and 0 to basename.

The following keys modify the selection:

    @: append selection to previous kill and exit. For example, M-w d @ will append current function to last kill.
    C-w: kill selection and exit
    +, - and 1..9: expand/shrink selection
    0 shrink the selection to the initial size i.e. before any expansion
    SPC: cycle through things in easy-kill-alist
    C-SPC: turn selection into an active region
    C-g: abort
    ?: help
#+end_quote

#+BEGIN_SRC elisp :tangle emacs.el
  (use-package easy-kill
    :config
    (global-set-key [remap kill-ring-save] 'easy-kill)
    (global-set-key [remap mark-sexp] 'easy-mark))
#+END_SRC

*** ediff
Needed for magit diff comparisons, among other things.

#+BEGIN_SRC elisp :tangle emacs.el
    (use-package ediff
    :custom
    (diff-command "wdiff")
    (diff-switches "")
    (ediff-window-setup-function 'ediff-setup-windows-plain)
)
#+END_SRC
*** COMMENT god-mode
https://github.com/chrisdone/god-mode
Saves on typing.
#+BEGIN_SRC elisp :tangle emacs.el
     ;; good package to make a file reading mode much nicer
     (use-package god-mode
       :config
       (global-set-key (kbd "<escape>") 'god-mode-all)
       (setq god-exempt-major-modes nil
	     god-exempt-predicates nil)
       (define-key god-local-mode-map (kbd ".") 'repeat)
       (require 'god-mode-isearch)
       (define-key isearch-mode-map (kbd "<escape>") 'god-mode-isearch-activate)
       (define-key god-mode-isearch-map (kbd "<escape>") 'god-mode-isearch-disable)
       (define-key god-local-mode-map (kbd "<backspace>") 'scroll-down-command)
       (defun my-update-cursor ()
	 (setq cursor-type (if (or god-local-mode buffer-read-only)
			       'hbar
			     'box)))
       (add-hook 'god-mode-enabled-hook 'my-update-cursor)
       (add-hook 'god-mode-disabled-hook 'my-update-cursor))
#+END_SRC
*** helpful
 #+BEGIN_SRC elisp :tangle emacs.el
	(use-package helpful)
#+END_SRC    
*** COMMENT Highlighting Family
There are a lot of highlighting options out there
**** COMMENT hilock
https://github.com/emacs-mirror/emacs/blob/master/lisp/hi-lock.el     
 #+BEGIN_SRC elisp :tangle emacs.el
	(use-package hi-lock
	  :config
	  (global-hi-lock-mode 1))
#+END_SRC
**** hl-line+
 #+BEGIN_SRC elisp :tangle emacs.el
   (use-package hl-line+
     :custom
     (global-hl-line-mode t)
     (hl-line-flash-show-period 1.0)
     (hl-line-inhibit-highlighting-for-modes '(dired-mode))
     (hl-line-overlay-priority -100) ;; sadly, seems not observed by diredfl
   )
#+END_SRC


**** hl-todo
https://github.com/tarsius/hl-todo
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package hl-todo
    :custom
    (hl-todo-keyword-faces
     '(("TODO" . "#dc752f")
       ("NEXT" . "#dc752f")
       ("THEM" . "#2aa198")
       ("PROG" . "#268bd2")
       ("OKAY" . "#268bd2")
       ("DONT" . "#d70000")
       ("FAIL" . "#d70000")
       ("DONE" . "#86dc2f")
       ("NOTE" . "#875f00")
       ("KLUDGE" . "#875f00")
       ("HACK" . "#875f00")
       ("TEMP" . "#875f00")
       ("FIXME" . "#dc752f")
       ("XXX" . "#dc752f")
       ("XXXX" . "#dc752f")
       ("???" . "#dc752f")))
    :config
    (global-hl-todo-mode t))
#+END_SRC
**** COMMENT highlight.el 
	new one I'm trying, created by the excellent Drew Adams.
	Error:
	=Error (use-package): highlight/:catch: Symbol’s value as variable is void: facemenu-menu=

#+BEGIN_SRC elisp :tangle emacs.el
  (use-package highlight
  :custom
   (highlight-changes-colors '("#d33682" "#6c71c4"))
   (highlight-symbol-colors
     (--map
      (solarized-color-blend it "#002b36" 0.25)
      '("#b58900" "#2aa198" "#dc322f" "#6c71c4" "#859900" "#cb4b16" "#268bd2")))
   (highlight-symbol-foreground-color "#93a1a1")
   (highlight-tail-colors
     '(("#073642" . 0)
       ("#546E00" . 20)
       ("#00736F" . 30)
       ("#00629D" . 50)
       ("#7B6000" . 60)
       ("#8B2C02" . 70)
       ("#93115C" . 85)
       ("#073642" . 100)))
    )
#+END_SRC
*** COMMENT Hydra Family
**** hydra
     https://github.com/abo-abo/hydra
 #+BEGIN_SRC elisp :tangle emacs.el
    ;; GOLDEN PACKAGE
    (use-package hydra
      :config (tsa/safe-load-file "lisp/tsa-hydra.el"))
#+END_SRC
**** Ivy Hydra
Necessary for spell-check actions
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package ivy-hydra
    :after ispell
    :custom
    (ivy-display-style nil)
    (ivy-minibuffer-faces nil)
    (ivy-switch-buffer-faces-alist nil))
#+END_SRC

*** Keyboard key management
**** whichkey
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package which-key
    :delight
    :config
    (which-key-mode))
#+END_SRC
*** Magit
Golden package.
#+BEGIN_SRC elisp :tangle emacs.el
  ;; GOLDEN PAKAGE
  (use-package magit
     :defer 3
     :bind (:map magit-section-mode-map
		([M-tab] . iflipb-next-buffer)
		("M-TAB" . iflipb-next-buffer)
		("M-S-TAB" . iflipb-previous-buffer)
		:map magit-mode-map
		([M-tab] . iflipb-next-buffer)
		("M-TAB" . iflipb-next-buffer)
		("M-S-TAB" . iflipb-previous-buffer))
		:custom 
	 (vc-annotate-background nil)
	 (vc-annotate-color-map
	  '((20 . "#cc6666")
	    (40 . "#de935f")
	    (60 . "#f0c674")
	    (80 . "#b5bd68")
	    (100 . "#8abeb7")
	    (120 . "#81a2be")
	    (140 . "#b294bb")
	    (160 . "#cc6666")
	    (180 . "#de935f")
	    (200 . "#f0c674")
	    (220 . "#b5bd68")
	    (240 . "#8abeb7")
	    (260 . "#81a2be")
	    (280 . "#b294bb")
	    (300 . "#cc6666")
	    (320 . "#de935f")
	    (340 . "#f0c674")
	    (360 . "#b5bd68")))
	 (vcannotate-very-old-color nil)
	 (vc-follow-symlinks t)
	 (vc-handled-backends nil) ;; disable built-in vc
	 ;(vc-handled-backends '(Git))
    :config
    (add-hook 'ediff-prepare-buffer-hook #'show-all) ;; Expand orgmode files before ediffing them
;    (global-magit-file-mode)
    (global-set-key (kbd "C-x g") 'magit-status)
    (setq magit-diff-use-overlays nil))
#+END_SRC
*** markdown
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package markdown-mode
    :mode "\\.md\\'")
#+END_SRC
*** multiple-cursors
https://github.com/magnars/multiple-cursors.el
Another package that suggests power not had in GUI editors

#+BEGIN_SRC elisp :tangle emacs.el
  (use-package multiple-cursors
    :bind (("C-M-n" . mc/mark-next-lines))
    :custom 
    (mc/always-run-for-all t))
#+END_SRC
*** Parens and Structural Editing
**** smarparens
https://github.com/Fuco1/smartparens
The new parinfer for structural editing.

 #+BEGIN_SRC elisp :tangle emacs.el
   (use-package smartparens
       :demand t
       :bind (("C-<f5>" . smartparens-mode))
       :custom-face
       (sp-show-pair-enclosing ((t (:inherit highlight :background "orange red"))))
       (sp-show-pair-match-face ((t (:background "#Ff4500" :foreground "black" :weight ultra-bold))))
   
       :config
       (show-smartparens-global-mode)
       (sp-use-paredit-bindings)
       (add-hook 'emacs-lisp-mode-hook 'turn-on-smartparens-strict-mode)
       (add-hook 'clojure-mode-hook 'turn-on-smartparens-strict-mode)
       (add-hook 'cider-repl-mode-hook #'turn-on-smartparens-strict-mode)
       (add-hook 'message-mode-hook 'turn-off-smartparens-mode)
       (add-hook 'org-mode-hook 'turn-off-smartparens-mode)
       (bind-keys
	:map smartparens-strict-mode-map
	(";" . sp-comment)
	("M-[" . sp-backward-barf-sexp)
	("M-]" . sp-forward-slurp-sexp)
	("M-f" . sp-forward-symbol)
	("M-b" . sp-backward-symbol)
	("M-a" . sp-beginning-of-sexp)
	("M-e" . sp-end-of-sexp)))
#+END_SRC
***** smartparens config
Setup that makes Clojure/Elisp not double '
 #+BEGIN_SRC elisp :tangle emacs.el
    (use-package smartparens-config
	   :straight (:type built-in))
  #+END_SRC
**** paren (built-in)
Turn on paren showing
 #+BEGIN_SRC elisp :tangle emacs.el
     (use-package paren
       :config
       (show-paren-mode 1))
#+END_SRC
*** [#A] [[https://github.com/bbatsov/helm-projectile][Projectile]]
Must have for project navigation. 
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package projectile
    :delight '(:eval (concat " [P: " (projectile-project-name) "]"))
    :custom
    (projectile-completion-system 'default)
    (projectile-switch-project-action 'projectile-find-file)
    :config
    (projectile-global-mode)
    (define-key projectile-command-map (kbd "s g") 'consult-git-grep))
#+END_SRC
*** [[https://www.emacswiki.org/emacs/RainbowDelimiters][rainbow-delimeters]]
Excellent paren highlighting for lisp modes (or others). 

#+BEGIN_SRC elisp :tangle emacs.el
      (use-package rainbow-delimiters
	:config
	(add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC
*** [[https://github.com/Fanael/rainbow-identifiers][rainbow-identifiers]]
Highlight variables with a rainbow
#+BEGIN_SRC elisp :tangle emacs.el
      (use-package rainbow-identifiers
	:config
	(add-hook 'prog-mode-hook 'rainbow-identifiers-mode))
#+END_SRC
*** Rainbow-mode
Display CSS colors. Where is the .el for this actually obtained?

#+BEGIN_SRC elisp :tangle emacs.el
  (use-package rainbow-mode
    :mode "\\.css")
#+END_SRC
*** recentf
https://www.emacswiki.org/emacs/RecentFiles
Recent files
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package recentf
    :straight (:type built-in)
    :bind (("C-x C-r" . consult-recent-file))
    :config
    (setq recentf-max-menu-items 100)
    (recentf-mode 1))
#+END_SRC
*** shell
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package shell
    :straight (:type built-in)
    :custom
    (shell-command-prompt-show-cwd t)
    (comint-completion-addsuffix nil)
    (ansi-color-faces-vector
     '[default bold shadow italic underline bold bold-italic bold])
    (ansi-term-color-vector
     '[unspecified "#1F1611" "#660000" "#144212" "#EFC232" "#5798AE" "#BE73FD" "#93C1BC" "#E6E1DC"] t)
    (async-shell-command-buffer 'new-buffer)
    :config ;http://stackoverflow.com/questions/704616/something-wrong-with-emacs-shell
    (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)

    (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
    (add-to-list 'display-buffer-alist
		 '("^\\*shell\\*$" . (display-buffer-same-window)))) ;; don't open shell in a new window
#+END_SRC

*** COMMENT [[https://github.com/akicho8/string-inflection][string-inflection]]
underscore -> UPCASE -> CamelCase conversion of names.  Very useful when necessary, but I don't need this very often.

#+BEGIN_SRC elisp :tangle emacs.el
      (use-package string-inflection
	
	:bind (("C-c C-u" . string-inflection-all-cycle)))
#+END_SRC

*** Text-, Window-navigation and frame management
**** ace-link
https://github.com/abo-abo/ace-link
  #+BEGIN_SRC elisp :tangle emacs.el
    (use-package ace-link
      :bind (:map gnus-summary-mode-map 
		  ("M-o" . ace-link-gnus)
		  :map gnus-article-mode-map
		  ("M-o" . ace-link-gnus)
		  :map org-mode-map
		  ("M-o" . ace-link-org)
		  :map w3m-mode-map
		  ("M-o" . ace-link-w3m)
		  )
      :config
      (ace-link-setup-default))
#+END_SRC

**** ace-window
[2020-08-29 Sat] Still necessary for swap-windows
[2020-05-26 Tue] Using winum instead
     Multi-screen window-hopping made easy
  #+BEGIN_SRC elisp :tangle emacs.el
    (use-package ace-window
      :bind (("s-<tab>" . ace-window)))
  #+END_SRC
**** ace-popup-menu
     For extendedace navigation. 
#+BEGIN_QUOTE
Replace GUI popup menu in Emacs with something more efficient
#+END_QUOTE

  #+BEGIN_SRC elisp :tangle emacs.el
      (use-package ace-popup-menu
	
	:config
	(ace-popup-menu-mode 1))
#+END_SRC
**** ace-jump-mode
https://github.com/winterTTr/ace-jump-mode
Rapid hopping around by line on screen. wrap-ins for work with ace-isearch. 

#+BEGIN_SRC elisp :tangle emacs.el
  (use-package ace-jump-mode
    :bind (("C-c SPC" . ace-jump-mode))
    :custom
    (ace-isearch-function 'ace-jump-char-mode)
    :config
    (setq ace-jump-mode-case-fold nil)
    (setq ace-jump-mode-submode-list '(ace-jump-line-mode ace-jump-char-mode ace-jump-word-mode)
	  ace-jump-mode-scope 'frame))
#+END_SRC
**** avy

#+begin_src elisp :tangle emacs.el
  (use-package avy
    :demand t
    :custom
    (avy-all-windows 'all-frames)
    (avy-background t)
    (avy-case-fold-search nil)
    (avy-highlight-first t)
    :custom-face
    (avy-lead-face ((t (:background "#F5f5f5" :foreground "#1E1C31" :weight bold))))
    (avy-lead-face-0 ((t (:inherit avy-lead-face :background "#Ff0000"))))
    (avy-lead-face-1 ((t (:inherit avy-lead-face :background "#32cd32"))))
    (avy-lead-face-2 ((t (:inherit avy-lead-face :background "#1e90ff")))))
#+end_src
**** Swiper
  The ivy isearch. https://github.com/abo-abo/swiper
    #+BEGIN_SRC elisp :tangle emacs.el
      (use-package swiper)
    #+END_SRC

**** ace-isearch
https://github.com/tam17aki/ace-isearch

One-button hop-arounds. Char nav with avy-goto-char. 
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package ace-isearch
    :demand t
    :delight
    :bind (:map isearch-mode-map
		("M-i" . consult-line-from-isearch) ;; doesn't quite work; doesn't know search string
		;("M-i" . ace-isearch-swiper-from-isearch)
		)
    :custom    
    (ace-isearch-function 'avy-goto-char)
    (ace-isearch-2-switch-function 'avy-goto-char-2)
    ;(ace-isearch-function-from-isearch 'ace-isearch-swiper-from-isearch)
    (ace-isearch-input-idle-delay 0.2)
    ;(ace-isearch-input-length 9)
    (ace-isearch-use-ace-jump (quote printing-char))
    (ace-isearch-use-function-from-isearch nil) ;; don't make long searches into fancy stuff
    (ace-isearch-use-jump (quote printing-char))

    :config
    (global-ace-isearch-mode t)
    (add-hook 'isearch-mode-hook
	    (function
	     (lambda ()
	       (define-key isearch-mode-map "\C-h" 'isearch-mode-help)
	       (define-key isearch-mode-map "\C-t" 'isearch-toggle-regexp)
	       (define-key isearch-mode-map "\C-c" 'isearch-toggle-case-fold)
	       (define-key isearch-mode-map "\C-j" 'isearch-edit-string)))))

        #+END_SRC

**** ace-jump-zap
https://github.com/waymondo/ace-jump-zap
Zapping is a very fast selective cut option.
      #+BEGIN_SRC elisp :tangle emacs.el
      (use-package ace-jump-zap	
	:bind (("M-z" . ace-jump-zap-to-char))
	:config
	(setq ajz/zap-function 'kill-region))
#+END_SRC
**** Windmove
     https://www.emacswiki.org/emacs/WindMove
 Navigating windows. 
 #+BEGIN_SRC elisp :tangle emacs.el
   (use-package windmove
     :config
     (setq windmove-default-keybindings t))
 #+END_SRC
**** Windresize
http://elpa.gnu.org/packages/windresize.html

#+begin_src elisp :tangle emacs.el
  (use-package windresize
    :defer t
    :bind ("C-c w" . windresize))
#+end_src

**** Winner
     https://www.emacswiki.org/emacs/WinnerMode
 Undo screen settings. 

Can factor in ignored buffers (or regexp) like =(add-to-list 'winner-boring-buffers "*helm M-x*")=
 #+BEGIN_SRC elisp :tangle emacs.el
   (use-package winner
     :straight (:type built-in)
     :config
     (winner-mode 1))
 #+END_SRC

*** Themes and visuals
**** [#A] Telephone mode-line
     https://github.com/dbordak/telephone-line
 #+BEGIN_SRC elisp :tangle emacs.el
   (use-package telephone-line
     :after winum
     :custom 
     (telephone-line-mode t)
     (default-tab-width 3 t)
     (telephone-line-primary-left-separator 'telephone-line-cubed-left)
     (telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left)
     (telephone-line-primary-right-separator 'telephone-line-cubed-right)
     (telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
     (telephone-line-height 24)
     (telephone-line-evil-use-short-tag t)  
     :config     
     (setq telephone-line-faces '((evil . telephone-line-modal-face)
				  (modal . telephone-line-modal-face)
				  (ryo . telephone-line-ryo-modal-face)
				  (accent telephone-line-accent-active . telephone-line-accent-inactive)
				  (nil mode-line . mode-line-inactive)
				  (winum . (winum-face . winum-face))))
     (telephone-line-defsegment telephone-line-org-clock-segment ()
       (when (telephone-line-selected-window-active)
	 (if (and (functionp 'org-clocking-p) (org-clocking-p))
	     (org-clock-get-clock-string))))
     (telephone-line-defsegment telephone-line-pdf-segment ()
       (when (eq major-mode 'pdf-view-mode)
	 (propertize (pdf-view-page-number)
		     'face '(:inherit)
		     'display '(raise 0.0)
		     'mouse-face '(:box 1))))
     (telephone-line-defsegment telephone-line-winum-segment ()
       (propertize (eval (cadr winum--mode-line-segment))
		   'face '(:box (:line-width 2 :color "cyan" :style released-button))		
		   'display '(raise 0.0)
		   'mouse-face '(:box 1)))
     (setq telephone-line-lhs '((winum . (telephone-line-winum-segment))
				(accent . (telephone-line-pdf-segment
					   telephone-line-vc-segment
					   telephone-line-erc-modified-channels-segment
					   telephone-line-process-segment))
				(nil . (telephone-line-projectile-segment
					telephone-line-buffer-segment
					telephone-line-org-clock-segment
					))))
     ;(setq telephone-line-center-rhs '((evil . (telephone-line-battery-segment))))
     (setq telephone-line-rhs '((nil . (telephone-line-flycheck-segment					
					))
				(accent . (telephone-line-major-mode-segment))
				(evil . (telephone-line-airline-position-segment))))
     (telephone-line-mode t))
#+END_SRC

**** Modus Themes
https://protesilaos.com/modus-themes/
Highly customizable, avoids some of the problems Doom caused my buffer-completion.

#+begin_src  elisp :tangle emacs.el
  (use-package modus-themes
    :straight (modus-themes :type git :host gitlab :repo "protesilaos/modus-themes")
    :custom
    (modus-themes-headings
     '((t . rainbow-line)))
    (modus-themes-slanted-constructs t)
    (modus-themes-bold-constructs nil)
    (modus-theme-mode-line '3d)
    (modus-themes-intense-hl-line t)
    (modus-themes-completions 'opinionated)
    (modus-themes-lang-checkers 'intense-foreground)
    :init
    ;; Load the theme files before enabling a theme
    (modus-themes-load-themes)
    :bind (("C-c T" . modus-themes-toggle))
    :config
    ;(modus-themes-load-operandi)
    (modus-themes-load-vivendi)
    )
#+end_src

*** tramp
SSH and remote-file editing easily
#+BEGIN_SRC elisp :tangle emacs.el
  ;; comes with emacs, but still GOLDEN PACKAGE for anyone who works on multiple servers
  (use-package tramp
    :straight (:type built-in)
    :defer t
    :custom
    (tramp-default-method "ssh")
    (tramp-completion-reread-directory-timeout nil)
    (tramp-default-remote-shell "/bin/bash")
    (tramp-encoding-shell "/bin/bash")
    ;(vc-handled-backends nil)
    ;; https://github.com/emacs-helm/helm/issues/981
    :config
    (add-to-list 'tramp-default-proxies-alist
		 '(nil "\\`root\\'" "/ssh:%h:"))
    (add-to-list 'tramp-default-proxies-alist
		 '((regexp-quote (system-name)) nil nil)))
#+END_SRC
*** Transient
**** transient package
     Alternative to Hydra? 
     https://github.com/magit/transient
     https://www.reddit.com/r/emacs/comments/mujxm7/weekly_tipstricketc_thread/gv8jxz5?utm_source=share&utm_medium=web2x&context=3
    
     #+begin_src elisp :tangle emacs.el
       (use-package transient
	 :after org
	 ;; comes installed with Magit, no need to install
	 :straight nil
	 ;; Anything not in a binding below needs to be called-out as a command
	 :commands (transient-define-prefix)
	 :init
	 (autoload 'org-store-link "org")
	 :bind*
	 ;("C-M-o" . tsa/transient-window)
	 ;("C-c o" . tsa/transient-global-org)
	 ("C-z" . tsa/transient-shell)
	 ;("C-;" . tsa/transient-multiplecursors)
	 ("C-h" . tsa/transient-help) ;; risky over-writing help?
	 ;("M-g" . tsa/transient-goto)
	 ("M-s h" . tsa/transient-highlight)
	 ("C-c b" . tsa/transient-bbdb)
	 ("C-x M-e" . tsa/transient-w3m)
	 ;("<f1>" . tsa/hydra-fkeys/body)
	 ("<f12>" . tsa-transient-spelling))
 #+end_src
**** tsa-transient
The Transient commands I use.

***** Transient window and buffer navigation
****** Helper functions
***** transient-ace-cmd
  Ace-window but go back to the Transient

  #+BEGIN_SRC elisp :tangle emacs.el
    ;;; Usage Functions
    (defun transient-ace-cmd ()
      (interactive)
      (ace-window 1)
      (add-hook 'ace-window-end-once-hook
		'tsa/transient-window))
 #+END_SRC

******* tsa/split-vertical
 Split window vertically and move to the split

 #+BEGIN_SRC elisp :tangle emacs.el
    (defun tsa/split-vertical ()
      (interactive)
      (split-window-right)
      (windmove-right))
 #+END_SRC
******* tsa/split-horizontal
 Split window horizontally and move to the split

 #+BEGIN_SRC elisp :tangle emacs.el
    (defun tsa/split-horizontal ()
      (interactive)
      (split-window-below)
      (windmove-down))
 #+END_SRC
******* tsa/screen-swap
 Swap two screens (windows) with eachother, then back to transient.

 #+BEGIN_SRC elisp :tangle emacs.el
   (defun tsa/screen-swap ()
     (interactive)
     (ace-window 4)
     ;; (add-hook 'ace-window-end-once-hook
     ;; 	    'transient-window)
     )
 #+END_SRC
******* tsa/del-window
 Kill a window

 #+BEGIN_SRC elisp :tangle emacs.el
   (defun tsa/del-window ()
     (interactive)
     (ace-window 16)
     (add-hook 'ace-window-end-once-hook
	       'transient-window))
 #+END_SRC
******* tsa/split-window-4
 For large screens (like my TV), make the screen into a quad. Do nothing if we already have any splits.

 #+BEGIN_SRC elisp :tangle emacs.el
   (defun tsa/split-window-4 ()
     "Split into 4 windows"
    (interactive)
    (when (= 1 (length (window-list)))
      (split-window-vertically)
      (split-window-horizontally)
      (other-window 2)
      (split-window-horizontally)))
 #+END_SRC
******* tsa/correct-all
 #+BEGIN_SRC elisp :tangle emacs.el
   (defun tsa/correct-all () 
     (interactive)
     (setq current-prefix-arg '(4))
     (call-interactively 'flyspell-correct-wrapper))
#+END_SRC
******* tsa/projectile
      Choose files from this project or (=C-u=) choose projects. 
#+BEGIN_SRC  elisp :tangle emacs.el
  (defun tsa/projectile (&optional choose-project)
    "Open the scratch buffer. With c-u, in other window."
    (interactive "P")
    (let ((scratch "*scratch*"))
      (if choose-project (projectile-switch-project)
	(projectile-find-file))))
#+END_SRC
******* tsa/open-scratch
      open or switch to scratch buffer.
#+BEGIN_SRC  elisp :tangle emacs.el
  (defun tsa/open-scratch (&optional same-window)
    "Open the scratch buffer. With c-u, in other window."
    (interactive "P")
    (let ((scratch "*scratch*"))
      (if same-window (switch-to-buffer scratch)
	(switch-to-buffer-other-window scratch))))
#+END_SRC
***** Transients
instead of hydra

****** tsa/transient-highlight
 #+BEGIN_SRC elisp :tangle emacs.el
   (transient-define-prefix tsa/transient-highlight ()
     "Persistent Highlights"
     [["Highlight"
       ("r" "Highlight regexp" highlight-lines-matching-regexp)
       ;("c" "Column Highlight Mode" column-highlight-mode)
       ("X" "highlight changes (global)" global-highlight-changes-mode)
       ("x" "Highlight changes (local)" highlight-changes-mode)
       ;("e" "Global highlight edits" global-semantic-highlight-edits-mode)
       ("l" "Highlight lines" highlight-lines-matching-regexp)
       ("b" "Compare buffers" highlight-compare-buffers)
       ("f" "Compare file" highlight-compare-with-file)
       ("p" "Highlight Phrase" highlight-phrase)
       ("r" "Highlight regexp" highlight-regexp)
       ("." "Highlight symbol at point" highlight-symbol-at-point)
       ("u" "Unhighlight" unhighlight-regexp)
       ]])
 #+END_SRC

****** tsa/transient-multiplecursors
 #+BEGIN_SRC elisp :tangle emacs.el
    (transient-define-prefix tsa/transient-multiplecursors ()
      "MultiCursors"
      :transient-suffix 'transient--do-stay  
      [["Multiple Cursors"
	("n" "next~" mc/mark-next-lines)
	("N" "un next~" mc/unmark-next-like-this)
	("p" "prev~" mc/mark-previous-like-this)
	("P" "un prev~" mc/unmark-previous-like-this)
	("a" "all~" mc/mark-all-like-this)
	("r" "all-region" mc/mark-all-in-region)
	("d" "all-dwim" mc/mark-all-dwim)
	("." "mark-pop" mc/mark-pop)
	("w" "words" mc/mark-all-words-like-this)
	("#" "numbers" mc/insert-numbers)]])
 #+END_SRC
****** tsa/transient-w3m
eww helpers
 #+BEGIN_SRC elisp :tangle emacs.el
   (transient-define-prefix tsa/transient-w3m ()
     "W3M"
     ["W3M"
      ("e" "🔍 search" w3m-search)
      ("n" "🏠 new" w3m)
      ("h" "history" w3m-db-history)
      ("b" "buffers" w3m-select-buffer)
      ])
 #+END_SRC
****** tsa/transient-spelling
Spell check convenience.

 #+BEGIN_SRC elisp :tangle emacs.el
   (transient-define-prefix tsa-transient-spelling ()
     "Spelling"
     ["Spelling"
      ("<f12>" "spell buffer" flyspell-buffer :transient t)
      ("<f11>" "spell correct" tsa/correct-all)
      ("<f10>" "one correct" flyspell-correct-wrapper)]
     )
 #+END_SRC

****** tsa/transient-shell
Having the variety of shell-types available at fingertip. better-shell is easily the most common, though.

 #+BEGIN_SRC elisp :tangle emacs.el
   (transient-define-prefix tsa/transient-shell
     "Shell commands to be used"
     ["Shell Commands"
      [("z" "bettersh" better-shell-shell)
       ("r" "remote" better-shell-remote-open)
       ("e" "eshell" eshell)
       ("t" "term" term)
       ]])
 #+END_SRC
****** tsa/transient-help
https://www.reddit.com/r/emacs/comments/f3o0v8/anyone_have_good_examples_for_transient/

       #+begin_src elisp :tangle emacs.el
	 (transient-define-prefix tsa/transient-help ()
	   "Help commands that I use. A subset of C-h with others thrown in."
	   ["Help Commands"
	    ["Mode & Bindings"
	     ("m" "Mode" describe-mode)
	     ("b" "Major Bindings" which-key-show-full-major-mode)
	     ("B" "Minor Bindings" which-key-show-full-minor-mode-keymap)
	     ("d" "Descbinds" tsa/consult-descbinds)
	     ("D" "Descbinds" Helper-describe-bindings)
	     ("t" "Top Bindings  " which-key-show-top-level)]
	    ["Describe"
	     ("C" "Command" helpful-command)
	     ("f" "Function" helpful-callable)
	     ("v" "Variable" helpful-variable)
	     ("k" "Key" helpful-key)
	     ("c" "Key Briefly" describe-key-briefly)
	     ]
	    ["Info on"
	     ("C-m" "Linux Manual" man)
	     ("C-c" "Emacs Command" Info-goto-emacs-command-node)
	     ("C-f" "Function" describe-function)
	     ("C-v" "Variable" describe-variable)     
	     ("C-k" "Emacs Key" Info-goto-emacs-key-command-node)
	     ]
	    ["Goto Source"
	     ("L" "Library" find-library-other-frame)
	     ("F" "Function" find-function-other-frame)
	     ("V" "Variable" find-variable-other-frame)
	     ("K" "Key" find-function-on-key-other-frame)
	     ]
	    ]
	   [
	    ["Internals"
	     ("u" "Insert Unicode Char" insert-char)
	     ("I" "Input Method" describe-input-method)
	     ("G" "Language Env" describe-language-environment)
	     ("S" "Syntax" describe-syntax)
	     ("O" "Coding System" describe-coding-system)
	     ("C-o" "Coding Brief" describe-current-coding-system-briefly)
	     ("T" "Display Table" describe-current-display-table)
	     ("e" "Echo Messages" view-echo-area-messages)
	     ("l" "Lossage" view-lossage)
	     ]
	    ["Describe"
	     ("s" "Symbol" helpful-symbol)
	     ("." "At Point   " helpful-at-point)
	     ("C-f" "Face" describe-face)
	     ("w" "Where Is" where-is)
	     ("=" "Position" what-cursor-position)
	     ]
	    ["Info Manuals"
	     ("C-i" "Info" info)
	     ("C-4" "Other Window " info-other-window)
	     ("C-e" "Emacs" info-emacs-manual)
	     ("C-m" "Linux Man" man)
	     ]
	    ]
	   )
       #+end_src
****** transient-global-org
The giant org transient, intended to be used everwhere, including in exwm windows.

 #+BEGIN_SRC elisp :tangle emacs.el
   (transient-define-prefix tsa/transient-global-org
     "Orgmode Master Transient"
     ;; (:color blue
     ;; :hint nil
     ;; :body-pre (setq exwm-input-line-mode-passthrough ''t)
     ;; :post (setq exwm-input-line-mode-passthrough nil))
     [["Clocks"
       ("C-t" "timer start"  org-timer-start)
       ("C-s" "timer stop"  org-timer-stop)
       ("w" "clock-in to recent task" org-mru-clock-in)
       ("W" "Clock in the last task" org-clock-in-last)
       ("o" "Clock Out" org-clock-out)
       ("j" "goto clock" org-clock-goto)
       ("J" "Go to a clock" (lambda () (interactive) (org-clock-goto '(4))))]

      ["Timers"
       ("r" "Set Timer" org-timer-set-timer)
       ("p" "Print org timer" org-timer)]

      ["Hugo Blogging"
       ("h" "export to hugo" hugo)
       ("u" "upload" hugo-publish-up)
       ("t" "publish and upload" hugo-total)
       ]

      ["Misc"
       ("g" "Export as Markdown" org-gfm-export-as-markdown)
       ("\\" "toggle pretty entities" org-toggle-pretty-entities)
       ("l" "go to last stored capture" org-capture-goto-last-stored)
       ("," "set org priority" org-priority)]])
#+END_SRC
****** Transient-window: The Big Transient for Ultimate Navigation
******* Helper-fns
******** COMMENT req windmove
  #+BEGIN_SRC elisp :tangle emacs.el	
	(require 'windmove) ; also already added in my emacs-el
#+END_SRC
******** tsa/move-splitter-left
#+BEGIN_SRC elisp :tangle emacs.el	
	(defun tsa/move-splitter-left (arg)
	  "Move window splitter left."
	  (interactive "p")
	  (if (let ((windmove-wrap-around))
		(windmove-find-other-window 'right))
	      (shrink-window-horizontally arg)
	    (enlarge-window-horizontally arg)))
#+END_SRC
******** tsa/move-splitter-right
#+BEGIN_SRC elisp :tangle emacs.el	
	(defun tsa/move-splitter-right (arg)
	  "Move window splitter right."
	  (interactive "p")
	  (if (let ((windmove-wrap-around))
		(windmove-find-other-window 'left))
	      (enlarge-window-horizontally arg)
	    (shrink-window-horizontally arg)))
#+END_SRC
******** tsa/move-splitter-up
#+BEGIN_SRC elisp :tangle emacs.el	
	(defun tsa/move-splitter-up (arg)
	  "Move window splitter up."
	  (interactive "p")
	  (if (let ((windmove-wrap-around))
		(windmove-find-other-window 'up))
	      (enlarge-window arg)
	    (shrink-window arg)))
#+END_SRC
******** tsa/exwm-workspace-swap
#+BEGIN_SRC  elisp :tangle emacs.el	
  (defun tsa/exwm-workspace-swap ()
    "Swap workspaces, querying for which to swap if there are more than 2"
    (interactive)
    (if (= 2 (exwm-workspace--count))
	(let ((w1 (first exwm-workspace--list))
	      (w2 (second exwm-workspace--list)))
	  (exwm-workspace-swap w1 w2))
      (call-interactively 'exwm-workspace-swap)))
#+END_SRC

******** tsa/move-splitter-down
#+BEGIN_SRC elisp :tangle emacs.el	
	(defun tsa/move-splitter-down (arg)
	  "Move window splitter down."
	  (interactive "p")
	  (if (let ((windmove-wrap-around))
		(windmove-find-other-window 'up))
	      (shrink-window arg)
	    (enlarge-window arg)))
#+END_SRC
******** window-size-keys                                             :ARCHIVE:
#+BEGIN_SRC elisp :tangle emacs.el	
	(global-set-key [C-up] 'enlarge-window)
	(global-set-key [C-down] (lambda () (interactive)
				   (enlarge-window -1)))
#+END_SRC
****** transient-goto
      in-buffer navigation shortcuts. 
 #+BEGIN_SRC elisp :tangle emacs.el
   (transient-define-prefix tsa/transient-scroll ()
     "WIP Navigate screen repeatably. but suffix or infix don't seem to do it"
     [["Navigate Viewport"
       ("," "scroll leftward" scroll-right)
       ("." "scroll rightward" scroll-left)
       ("[" "backward a page" backward-page)
       ("]" "forward a page" forward-page)]])

   (transient-define-prefix tsa/transient-goto ()
     "Buffer nav"
     [["Go To in Buffer"
       ("g" "line" goto-line)
       ("TAB" "column" move-to-column)
       ("l" "jump to visible line" ace-jump-line-mode)
       ("c" "char" goto-char)
       ("o" "ace" ace-link)   
       ]
      ["Navigate Viewport"
       ("[" "Navigate Viewport" tsa/transient-scroll)
       ]
      ["Errors"
       ("n" "next err" next-error)
       ("p" "prev err" previous-error)]

      ["Replace"
       ("r" "query replace simple" anzu-query-replace)
       ("R" "query replace regexp" anzu-query-replace-regexp)
       ("t" "query replace thing at cursor" anzu-query-replace-at-cursor)
       ("T" "clobber-replace thing at cursor" anzu-query-replace-at-cursor-thing)
       ]])
#+END_SRC
****** COMMENT transient-gnus-group
Not specifically bound, but a shortcut for dealing with gnus
#+BEGIN_SRC elisp :tangle emacs.el
      (transient-define-prefix transient-gnus-group ()
	"Gnus Group"
					      ;    ("TAB" gnus-topic-indent "indent")
					      ;    ("<tab>" gnus-topic-indent "indent")
	("#" gnus-topic-mark-topic "mark")
	("u" gnus-topic-unmark-topic "unmark")
	("C" gnus-topic-copy-matching "Copy-m")
	("D" gnus-topic-remove-group "DLT")
	("H" gnus-topic-toggle-display-empty-topics "Hide Empty")
	("M" gnus-topic-move-matching "Move-m")
	("S" gnus-topic-sort-map "sort")
	("c" gnus-topic-copy-group "copy")
	("h" gnus-topic-hide-topic "hide")
	("j" gnus-topic-jump-to-topic "jump")
	("m" gnus-topic-move-group "move")
	("N" gnus-topic-create-topic "new")
	("n" gnus-topic-goto-next-topic "→")
					      ;    ("TAB" gnus-topic-goto-next-topic "→")
	("<tab>" gnus-topic-goto-next-topic "→")
	("p" gnus-topic-goto-previous-topic "←")
					      ;    ("BACKTAB" gnus-topic-goto-previous-topic "←")
	("<backtab>" gnus-topic-goto-previous-topic "←")
	("r" gnus-topic-rename "rename")
	("s" gnus-topic-fold-this-topic "show")
	("DEL" gnus-topic-delete "delete")
	("SPC" nil "cancel"))
 #+END_SRC
****** transient-bbdb
Transient for helping with bbdb.

 #+BEGIN_SRC elisp :tangle emacs.el
   (transient-define-prefix tsa/transient-bbdb ()
     "BBDB Commands"
     ["BBDB"
      ("b" "Ivy BBDB" tsa/bbdb-list)
      ("B" "BBDB" bbdb)
      ("c" "Create" bbdb-create)
      ("x" "X-Field" bbdb-search-xfields)
      ("s" "Snarf" bbdb-snarf)]
     )
#+END_SRC
****** tsa/transient-fkeys
******* help fn: toggle-ace-mode
Determine whether to ace-search by char or word. 

  #+BEGIN_SRC elisp :tangle emacs.el
     (defun tsa/toggle-ace-mode ()
       "Toggle whether to search by word or char"
       (interactive)
       (if (function-equal ace-isearch-function 'ace-jump-char-mode)
	   (progn 
	     (setq ace-isearch-function 'ace-jump-word-mode)
	     (message "Jump-Word Mode"))
	 (progn 
	   (setq ace-isearch-function 'ace-jump-char-mode)
	   (message "Jump-Char Mode"))))
#+END_SRC
******* tsa/transient-fkeys
Extends the f-keys to be documented and to concerve space. f-kays that aren't used super-frequently go here (ie. not =quick-org= or downloading mail

#+BEGIN_SRC elisp :tangle emacs.el
  (transient-define-prefix tsa/transient-fkeys
    "Transient for the <f#> keys"
    ["F-Keys"
    ("<f1>" "hide modeline" tsa/hide-mode-line)
    ("<C-f1>" "show filename" tsa/show-file-name)
    ("<f2>" "prev msg" tsa/insert-previous-message)
    ("<f3>" "Toggle search word//char" tsa/toggle-ace-mode)
    ("<f4>" "shorturl" tsa/yourls-shorten-at-point)
    ("<f5>" "truncate lines" toggle-truncate-lines)
    ("<f6>" "hl-line mode" global-hl-line-mode)
    ("<S-f6>" "hicol" column-highlight-mode )
    ("<f7>" "line num mode" display-line-numbers-mode)
    ("<C-f7" "scrollbar" toggle-scroll-bar)
    ("r" "revert buffer" revert-buffer)])
#+END_SRC

****** tsa/hide-mode-line
#+BEGIN_SRC elisp :tangle emacs.el
  (defun tsa/hide-mode-line (arg)
    "Hide or global hide-modeline for a transient. Doesn't work, though."  
    (interactive "p")
    (message (format "Arg is: %d" arg))
    (cond
     ((equal arg 1)
      ((lambda () (interactive) (hide-mode-line-mode))))
     ((equal arg 4)
      ((lambda () (interactive) (global-hide-mode-line-mode))))))
#+END_SRC
****** tsa/transient-window
How to compensate for transient colors? And "cancel" button? 
     
 #+begin_src elisp :tangle emacs.el
   (transient-define-prefix tsa/transient-window ()
     "Window navigation transient"
     :transient-suffix 'transient--do-stay  
     [["Movement"
       ("h" "focus ←" windmove-left)
       ("j" "focus ↓" windmove-down)
       ("k" "focus ↑" windmove-up)
       ("l" "focus →" windmove-right)]
      ["Resize"    
       ("q" "X←" tsa/move-splitter-left)
       ("w" "X↓" tsa/move-splitter-down)    
       ("e" "X↑" tsa/move-splitter-up)    
       ("r" "X→" tsa/move-splitter-right)]
      ["Switch"
       ("b" "buffer" switch-to-buffer)
       ("f" "find-file" find-file)
       ("g" "git-grep" consult-git-grep)
       ("p" "projectile" tsa/projectile)
       ("F" "follow" follow-mode)
       ("a" "ace 1" transient-ace-cmd)]
      ["Split"
       ("v" "vertical" tsa/split-vertical)
       ("x" "horizontal" tsa/split-horizontal)
       ("`" "exwm swap" tsa/exwm-workspace-swap)
       ("s" "swap" tsa/screen-swap)
       ("S" "split" toggle-window-split)
       ("d" "delete window" delete-window)
       ("D" "delete other" tsa/del-window)
       ("o" "delete other2" delete-other-windows)
       ;; ("z" (lambda ()
       ;; 	   (winner-undo)
       ;; 	   (setq this-command 'winner-undo)))
       ("Z" "winner redo" winner-redo)
					   ;("SPC" "" nil)
       ]
      ["Scroll"
       ("." "left" scroll-left)
       ("," "right" scroll-right)
       ("4" "quad view" tsa/split-window-4)
       ("=" "Scratch" tsa/open-scratch)
					   ;     (";TODO: " "" projectile-toggle-between-implementation-and-test "test<>imp")
       ]]
     )
     #+end_src
*** undo-tree
    https://www.emacswiki.org/emacs/UndoTree    
Nice visual, sometimes great for when undo history gets messed up
#+BEGIN_SRC elisp :tangle emacs.el
       (use-package undo-tree
	 
	 :delight undo-tree-mode
	 :bind (("C-x /" . undo-tree-visualize))
	 :config
	 (global-undo-tree-mode t))
#+END_SRC
*** COMMENT uuidgen                                                 :ARCHIVE:
https://github.com/kanru/uuidgen-el
Generate UUIDs
#+BEGIN_SRC elisp :tangle emacs.el
       (use-package uuidgen)
#+END_SRC
*** COMMENT Fonts
#+BEGIN_SRC elisp :tangle emacs.el
       (use-package unicode-fonts)
#+END_SRC

*** web basics
**** web-mode
polyglot mode for php, javascript, html, css

http://web-mode.org/
https://github.com/fxbois/web-mode
 #+BEGIN_SRC elisp :tangle emacs.el

   (let ((ext '(".html"
		".phtml"
		".php"
		".tpl"
		".asp"
		".jsp"
		".aspx"
		".erb"
		".mustache"
		".djhtml")))
     (regexp-opt ext))
   ;; "\\(?:\\.\\(?:aspx?\\|djhtml\\|erb\\|html\\|jsp\\|mustache\\|ph\\(?:p\\|tml\\)\\|tpl\\)\\)"
   (use-package web-mode
     :mode "\\(?:\\.\\(?:aspx?\\|djhtml\\|erb\\|html\\|jsp\\|mustache\\|ph\\(?:p\\|tml\\)\\|tpl\\)\\)")
 #+END_SRC

*** [#A] winum 
https://github.com/deb0ch/emacs-winum
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package winum
    :demand t
    ;:bind (("s-<tab>" . tsa/winum-or-switch))
    :custom-face
    (winum-face ((t (:background "cyan" :foreground "black" :weight ultra-bold :width extra-condensed))))
    :custom 
    (winum-auto-setup-mode-line nil)
    :config
    (winum-set-keymap-prefix (kbd "s-`"))
    (winum-mode t)
    (add-hook 'window-state-change-hook 'winum--update) ;; this hook is too early
    (defun tsa/winum-or-switch (&optional p)
      (interactive "p")
      (if (= 2 winum--window-count)
	  (other-frame p)
	(call-interactively 'winum-select-window-by-number))))
#+END_SRC
*** yasnippet
https://github.com/joaotavora/yasnippet
Snippets anywhere. 
#+BEGIN_SRC elisp :tangle emacs.el
  (use-package yasnippet
    :delight yas-minor-mode
    :custom
    (yas-indent-line 'fixed)
    :custom-face
    (yas-field-highlight-face ((t (:inherit secondary-selection))))
    :config
    (add-to-list 'yas-snippet-dirs "~/emacs/Snippets")
    (add-to-list 'yas-snippet-dirs "snippets/yasnippet-snippets/snippets")
    (use-package clojure-snippets )
    (yas-global-mode))
#+END_SRC
*** COMMENT load custom-file                                        :ARCHIVE:
#+BEGIN_SRC elisp :tangle emacs.el
(load-file custom-file)
#+END_SRC


* TODO personal lisp customization
Files under emacs/lisp representing customizations and functions I've written
** tsa-hydra
The Hydra commands I use.

*** Hydra window and buffer navigation
**** Helper functions
***** tsa/hydra-ace-cmd
  Ace-window but go back to the Hydra

  #+BEGIN_SRC elisp :tangle emacs.el
    ;;; Usage Functions
    (defun tsa/hydra-ace-cmd ()
      (interactive)
      (ace-window 1)
      (add-hook 'ace-window-end-once-hook
		'tsa/transient-window))
 #+END_SRC

***** hydra-split-vertical
 Split window vertically and move to the split

 #+BEGIN_SRC elisp :tangle emacs.el
    (defun hydra-split-vertical ()
      (interactive)
      (split-window-right)
      (windmove-right))
 #+END_SRC
***** hydra-split-horizontal
 Split window horizontally and move to the split

 #+BEGIN_SRC elisp :tangle emacs.el
    (defun hydra-split-horizontal ()
      (interactive)
      (split-window-below)
      (windmove-down))
 #+END_SRC
***** tsa/hydra-screen-swap
 Swap two screens (windows) with eachother, then back to hydra.

 #+BEGIN_SRC elisp :tangle emacs.el
    (defun tsa/hydra-screen-swap ()
      (interactive)
      (ace-window 4)
      (add-hook 'ace-window-end-once-hook
		'tsa/hydra-window))
 #+END_SRC
***** hydra-del-window
 Kill a window

 #+BEGIN_SRC elisp :tangle emacs.el
    (defun hydra-del-window ()
      (interactive)
      (ace-window 16)
      (add-hook 'ace-window-end-once-hook
		'tsa/transient-window))
 #+END_SRC
***** tsa/split-window-4
 For large screens (like my TV), make the screen into a quad. Do nothing if we already have any splits.

 #+BEGIN_SRC elisp :tangle emacs.el
    (defun tsa/split-window-4 ()
      "Split into 4 windows"
     (interactive)
     (if (= 1 (length (window-list)))
	 (progn (split-window-vertically)
		(split-window-horizontally)
		(other-window 2)
		(split-window-horizontally))))
 #+END_SRC
***** tsa/correct-all
 #+BEGIN_SRC elisp :tangle emacs.el
   (defun tsa/correct-all () 
     (interactive)
     (setq current-prefix-arg '(4))
     (call-interactively 'flyspell-correct-wrapper))
#+END_SRC
***** tsa/projectile
      Choose files from this project or (=C-u=) choose projects. 
#+BEGIN_SRC  elisp :tangle emacs.el
  (defun tsa/projectile (&optional choose-project)
    "Open the scratch buffer. With c-u, in other window."
    (interactive "P")
    (let ((scratch "*scratch*"))
      (if choose-project (projectile-switch-project)
	(projectile-find-file))))
#+END_SRC
***** tsa/open-scratch
      open or switch to scratch buffer.
#+BEGIN_SRC  elisp :tangle emacs.el
  (defun tsa/open-scratch (&optional same-window)
    "Open the scratch buffer. With c-u, in other window."
    (interactive "P")
    (let ((scratch "*scratch*"))
      (if same-window (switch-to-buffer scratch)
	(switch-to-buffer-other-window scratch))))
#+END_SRC
*** Hydras
This is where the difference between key-bindings and hydra function calls really comes into play.

**** tsa/hydra-multiplecursors
Some of these break because they are a hydra. E.g. the dwim. 

 #+BEGIN_SRC elisp :tangle emacs.el
   (defhydra tsa/hydra-multiplecursors (global-map "C-;"
					       :color red)
     "MultiCursors"
     ("n" mc/mark-next-lines "next~")
     ("N" mc/unmark-next-lines "un next~")
     ("p" mc/mark-previous-lines "prev~")
     ("P" mc/unmark-previous-lines "un prev~")
     ("a" mc/mark-all-like-this "all~")
     ("r" mc/mark-all-in-region "all-region")
     ("d" mc/mark-all-dwim "all-dwim")
     ("." mc/mark-pop "mark-pop")
     ("w" mc/mark-all-words-like-this "words")
     ("#" mc/insert-numbers "numbers")
     ("SPC" nil) )
 #+END_SRC
**** COMMENT hydra-eww
eww helpers
 #+BEGIN_SRC elisp :tangle emacs.el
    (defhydra hydra-w3m (:color blue)
      "EW3M"
   ("e" eww "eww")
   ("b" eww-switch-to-buffer "switch")
   ("B" eww-list-buffers "buffers")
   ("h" eww-list-histories "history"))
   ;; "Eww"


 #+END_SRC
**** tsa/hydra-w3m
eww helpers
 #+BEGIN_SRC elisp :tangle emacs.el
    (defhydra tsa/hydra-w3m (:color blue)
      "EW3M"
      ("e" w3m-search "w3m 🔍")
      ("E" w3m "w3m 🏠")
      ("h" w3m-db-history "history")
      ("b" w3m-select-buffer "buffers")
      )

   ;; "Eww"
   ;; ("e" eww "eww")
   ;; ("b" eww-switch-to-buffer "switch")
   ;; ("B" eww-list-buffers "buffers")
   ;;"h" eww-list-histories "history")

 #+END_SRC
**** tsa/hydra-spellcheck
Spell check convenience.

 #+BEGIN_SRC elisp :tangle emacs.el
   (global-set-key
    (kbd "<f12>")
    (defhydra tsa/hydra-spelling (:color red)
      "Shell"
      ("<f12>" flyspell-buffer "spell buffer")
      ("<f11>" tsa/correct-all "spell correct" :color blue)
      ("<f10>" flyspell-correct-wrapper "one correct")))
 #+END_SRC

**** tsa/hydra-shells
Having the variety of shell-types available at fingertip. better-shell is easily the most common, though.

 #+BEGIN_SRC elisp :tangle emacs.el
   (global-set-key
    (kbd "C-z")
    (defhydra tsa/hydra-shells (:color blue)
      "Shell"
      ("z" better-shell-shell "bettersh")
      ("C-z" better-shell-shell "bettersh")
      ("Z" better-shell-remote-open "better-remote")
      ("e" eshell "eshell")
      ("t" term "term")))
 #+END_SRC
**** tsa/hydra-global-org
The giant org hydra, intended to be used everwhere, including in exwm windows.

 #+BEGIN_SRC elisp :tangle emacs.el
      (global-set-key
       (kbd "C-c o")
       (defhydra tsa/hydra-global-org (:color blue
				  :hint nil
				  :body-pre (setq exwm-input-line-mode-passthrough ''t)
				  :post (setq exwm-input-line-mode-passthrough nil))

	 ("C-t"  org-timer-start "⏰ start")
	 ("C-s"  org-timer-stop "⏰ stop")
	 ("C-S"  org-timer-stop)
	 ;; Need to be at timer
	 ("r" org-timer-set-timer "⏰ set")
	 ("C-r"  org-timer-set-timer)
	 ;; Print timer value to buffer0:00:00 
	 ("p" org-timer "⏲ stat")
	 ("C-p"  org-timer)
	 ("w" (org-mru-clock-in ;org-clock-in '(4)
	       ) "🕑 clock-in")
	 ("C-w"  (org-clock-in '(4)))
	 ("o" org-clock-out "🕕 out")
	 ("C-o"  org-clock-out)
	 ;; Visit the clocked task from any buffer
	 ("j" org-clock-goto "⮏")
	 ("C-j"  org-clock-goto)
	 ("l" org-capture-goto-last-stored "⮰")
	 ("C-l"  org-capture-goto-last-stored)
	 ("," org-priority "orgp⤴")
	 ("C-,"  org-priority)
	 ("h" hugo "✍ hugo")
	 ("u" hugo-publish-up "✍ pub")
	 ("t" hugo-total "✍ total")
	 ("g" org-gfm-export-as-markdown "as🅫")
	 ("\\" org-toggle-pretty-entities "λ")
	 ("W" org-clock-in-last "Clock in the last task")      
	 ("J" (lambda () (interactive) (org-clock-goto '(4))) "Go to a clock")))
#+END_SRC
***** Hydra-window: The Big Hydra for Ultimate Navigation
***** Helper-fns
****** req windmove
  #+BEGIN_SRC elisp :tangle emacs.el	
	(require 'windmove) ; also already added in my emacs-el
#+END_SRC
****** tsa/hydra-move-splitter-left
#+BEGIN_SRC elisp :tangle emacs.el	
	(defun tsa/hydra-move-splitter-left (arg)
	  "Move window splitter left."
	  (interactive "p")
	  (if (let ((windmove-wrap-around))
		(windmove-find-other-window 'right))
	      (shrink-window-horizontally arg)
	    (enlarge-window-horizontally arg)))
#+END_SRC
****** tsa/hydra-move-splitter-right
#+BEGIN_SRC elisp :tangle emacs.el	
	(defun tsa/hydra-move-splitter-left (arg)
	  "Move window splitter right."
	  (interactive "p")
	  (if (let ((windmove-wrap-around))
		(windmove-find-other-window 'right))
	      (enlarge-window-horizontally arg)
	    (shrink-window-horizontally arg)))
#+END_SRC
****** tsa/hydra-move-splitter-up
#+BEGIN_SRC elisp :tangle emacs.el	
	(defun tsa/hydra-move-splitter-up (arg)
	  "Move window splitter up."
	  (interactive "p")
	  (if (let ((windmove-wrap-around))
		(windmove-find-other-window 'up))
	      (enlarge-window arg)
	    (shrink-window arg)))
#+END_SRC
****** tsa/exwm-workspace-swap
#+BEGIN_SRC  elisp :tangle emacs.el	
  (defun tsa/exwm-workspace-swap ()
    "Swap workspaces, querying for which to swap if there are more than 2"
    (interactive)
    (if (= 2 (exwm-workspace--count))
	(let ((w1 (first exwm-workspace--list))
	      (w2 (second exwm-workspace--list)))
	  (exwm-workspace-swap w1 w2))
      (call-interactively 'exwm-workspace-swap)))
#+END_SRC

****** tsa/hydra-move-splitter-down
#+BEGIN_SRC elisp :tangle emacs.el	
	(defun tsa/hydra-move-splitter-down (arg)
	  "Move window splitter down."
	  (interactive "p")
	  (if (let ((windmove-wrap-around))
		(windmove-find-other-window 'up))
	      (shrink-window arg)
	    (enlarge-window arg)))
#+END_SRC
****** window-size-keys                                             :ARCHIVE:
#+BEGIN_SRC elisp :tangle emacs.el	
	(global-set-key [C-up] 'enlarge-window)
	(global-set-key [C-down] (lambda () (interactive)
				   (enlarge-window -1)))
#+END_SRC
***** tsa/hydra-window
#+BEGIN_SRC elisp :tangle emacs.el	
  (bind-key* "C-M-o"
	     (defhydra tsa/hydra-window (:body-pre (setq exwm-input-line-mode-passthrough ''t)
					       :post (setq exwm-input-line-mode-passthrough nil))
	       "
  Movement^^        ^Split^         ^Switch^		^Resize^
  ----------------------------------------------------------------
  _h_ ←       	_v_ertical    	_b_uffer		_q_ X←
  _j_ ↓        	_x_ horizontal	_f_ind files	_w_ X↓
  _k_ ↑        	_z_ undo      	_a_ce 1		_e_ X↑
  _l_ →        	_Z_ redo      	_s_wap		_r_ X→
  _F_ollow	_S_witch  	_D_lt Other   			max_i_mize
  _SPC_ cancel	_o_nly this   	_d_elete	
  _,_ Scroll←			_p_roject
  _._ Scroll→                     _g_rep
  "
	       ("h" windmove-left )
	       ("C-h"  windmove-left )
	       ("j" windmove-down )
	       ("C-j"  windmove-down )
	       ("k" windmove-up )
	       ("C-k"  windmove-up )
	       ("l" windmove-right )
	       ("C-l"  windmove-right )
	       ("q" tsa/hydra-move-splitter-left)
	       ("C-q"  tsa/hydra-move-splitter-left)
	       ("w" tsa/hydra-move-splitter-down)
	       ("C-w"  tsa/hydra-move-splitter-down)
	       ("e" tsa/hydra-move-splitter-up)
	       ("C-e"  tsa/hydra-move-splitter-up)
	       ("r" tsa/hydra-move-splitter-right)
	       ("C-r"  tsa/hydra-move-splitter-right)
	       ("b" switch-to-buffer)
	       ("C-b"  switch-to-buffer)
	       ("f" find-file)
	       ("C-f"  find-file)
	       ("g" consult-git-grep :color blue)
	       ("p" tsa/projectile)
	       ("C-p"  tsa/projectile)
	       ("F" follow-mode)
	       ("C-F"  follow-mode)
	       ("a" tsa/hydra-ace-cmd)
	       ("C-a"  tsa/hydra-ace-cmd)
	       ("v" tsa/split-vertical)
	       ("C-v"  tsa/split-vertical)
	       ("x" tsa/split-horizontal)
	       ("C-x"  tsa/split-horizontal)
	       ("s" tsa/screen-swap)
	       ("C-s"  tsa/screen-swap)
	       ("S" toggle-window-split)
	       ("C-S" toggle-window-split)
	       ("d" delete-window)
	       ("C-d"  delete-window)
	       ("D" tsa/del-window)
	       ("C-D"  tsa/del-window)
	       ("o" delete-other-windows)
	       ("C-o"  delete-other-windows)
	       ("i" ace-maximize-window)
	       ("C-i"  ace-maximize-window)
	       ("z" (progn
		      (winner-undo)
		      (setq this-command 'winner-undo)))
	       ("C-z" (progn
			(winner-undo)
			(setq this-command 'winner-undo)))
	       ("Z" winner-redo)
	       ("C-Z"  winner-redo)
	       ("SPC" nil)
	       ("C-SPC"  nil)
	       ("." scroll-left)
	       ("," scroll-right)
	       ("4" tsa/split-window-4)
	       ("=" tsa/open-scratch "Scratch")
	       ("t" projectile-toggle-between-implementation-and-test "test<>imp")
	       ("`" tsa/exwm-workspace-swap "exwm swap")))
   #+END_SRC
**** tsa/hydra-goto
      in-buffer navigation shortcuts. 
 #+BEGIN_SRC elisp :tangle emacs.el
   (global-set-key
    (kbd "M-g")
    (defhydra tsa/hydra-goto ()
      "Go To"
      ("g" goto-line "line") ; reserve for normal M-g g function (may be different in some modes)
      ("M-g" goto-line "line")
      ("TAB" move-to-column "col")
      ("l" ace-jump-line-mode "ace line" :color blue)
      ("c" goto-char "char")
      ("n" next-error "next err")
      ("o" ace-link "ace" :color blue)
      ("p" previous-error "prev err")
      ("r" anzu-query-replace "qrep")
      ("R" anzu-query-replace-regexp "rep regex")
      ("t" anzu-query-replace-at-cursor "rep cursor")
      ("T" anzu-query-replace-at-cursor-thing "rep cursor thing")
      ("," scroll-right "scroll leftward")
      ("." scroll-left "scroll rightward")
      ("[" backward-page "back page")
      ("]" forward-page "forward page")
      ("SPC" nil "cancel")))
#+END_SRC
**** tsa/hydra-gnus-group
Not specifically bound, but a shortcut for dealing with gnus
#+BEGIN_SRC elisp :tangle emacs.el
      (defhydra tsa/hydra-gnus-group ()
	"Gnus Group"
					      ;    ("TAB" gnus-topic-indent "indent")
					      ;    ("<tab>" gnus-topic-indent "indent")
	("#" gnus-topic-mark-topic "mark")
	("u" gnus-topic-unmark-topic "unmark")
	("C" gnus-topic-copy-matching "Copy-m")
	("D" gnus-topic-remove-group "DLT")
	("H" gnus-topic-toggle-display-empty-topics "Hide Empty")
	("M" gnus-topic-move-matching "Move-m")
	("S" gnus-topic-sort-map "sort")
	("c" gnus-topic-copy-group "copy")
	("h" gnus-topic-hide-topic "hide")
	("j" gnus-topic-jump-to-topic "jump")
	("m" gnus-topic-move-group "move")
	("N" gnus-topic-create-topic "new")
	("n" gnus-topic-goto-next-topic "→")
					      ;    ("TAB" gnus-topic-goto-next-topic "→")
	("<tab>" gnus-topic-goto-next-topic "→")
	("p" gnus-topic-goto-previous-topic "←")
					      ;    ("BACKTAB" gnus-topic-goto-previous-topic "←")
	("<backtab>" gnus-topic-goto-previous-topic "←")
	("r" gnus-topic-rename "rename")
	("s" gnus-topic-fold-this-topic "show")
	("DEL" gnus-topic-delete "delete")
	("SPC" nil "cancel"))
 #+END_SRC
**** tsa/hydra-bbdb
Hydra for helping with bbdb.

 #+BEGIN_SRC elisp :tangle emacs.el
      (global-set-key
       (kbd "C-c b")
       (defhydra tsa/hydra-bbdb ()
	 "Go To"
	 ("b" tsa/bbdb-list "Ivy BBDB")
	 ("B" bbdb "BBDB")
	 ("c" bbdb-create "Create")
	 ("x" bbdb-search-xfields "X-Field")
	 ("s" bbdb-snarf "Snarf")
	 ("SPC" nil "cancel")
	 ))
#+END_SRC
**** tsa/hydra-fkeys
***** help fn: toggle-ace-mode
Determine whether to ace-search by char or word. 

  #+BEGIN_SRC elisp :tangle emacs.el
     (defun tsa/toggle-ace-mode ()
       "Toggle whether to search by word or char"
       (interactive)
       (if (function-equal ace-isearch-function 'ace-jump-char-mode)
	   (progn 
	     (setq ace-isearch-function 'ace-jump-word-mode)
	     (message "Jump-Word Mode"))
	 (progn 
	   (setq ace-isearch-function 'ace-jump-char-mode)
	   (message "Jump-Char Mode"))))
#+END_SRC
***** tsa/hide-mode-line
#+BEGIN_SRC elisp :tangle emacs.el
  (defun tsa/hide-mode-line (arg)
    "Hide or global hide-modeline for a hydra. Doesn't work, though."  
    (interactive "p")
    (message (format "Arg is: %d" arg))
    (cond
     ((equal arg 1)
      ((lambda () (interactive) (hide-mode-line-mode))))
     ((equal arg 4)
      ((lambda () (interactive) (global-hide-mode-line-mode))))))
#+END_SRC
***** tsa/hydra-fkeys
Extends the f-keys to be documented and to concerve space. f-kays that aren't used super-frequently go here (ie. not =quick-org= or downloading mail

#+BEGIN_SRC elisp :tangle emacs.el
  (defhydra tsa/hydra-fkeys
    (:color red)
    "F Keys"
    ("<f1>" tsa/hide-mode-line "modeline" :color blue)
    ("<C-f1" tsa/show-file-name "filename" :color blue)
    ("<f2>" tsa/insert-previous-message "prev msg")
    ("<f3>" tsa/toggle-ace-mode "Search w//c")
    ("<f4>" tsa/yourls-shorten-at-point "shorturl")
    ("<f5>" toggle-truncate-lines "truncate" :color blue)
    ("<f6>" global-hl-line-mode "hlline")
    ("<S-f6>" column-highlight-mode  "hicol")
    ("<f7>" display-line-numbers-mode "lnum")
    ("<C-f7" toggle-scroll-bar "scrollbar")
    ("r" revert-buffer "revert")
    ("SPC" nil "cancel" :color blue))
#+END_SRC
**** COMMENT hydra persp                                                    :ARCHIVE:
      If persp is being used, there are so many keys to manage, here's this. I'm not currently using persp, though, because it doesn't work well with exwm. 

#+BEGIN_SRC elisp :tangle emacs.el
  (bind-key*
   (kbd "C-M-p")
   (defhydra tsa/hydra-persp
     (:color blue)
     "Perspectives"
     ("n" persp-next "next" :color red)
     ("p" persp-prev "prev" :color red)
     ("s" persp-switch "switch")
     ("r" persp-rename "rename")
     ("a" persp-add-buffer "addb")
     ("b" persp-switch-to-buffer "buffer")
     ("i" persp-import "import")
     ("k" persp-remove-buffer "removeb")
     ;("w" persp-sav)
     ("K" persp-kill "killb")
     ("o" persp-mode "toggle persp")))
     #+END_SRC
** COMMENT Unpublished Tangles
Files not ready to be tangled yet
*** graphviz-dot-mode.el
 Created by Pieter Pareit, over a decade ago. 

 #+BEGIN_SRC elisp :tangle lisp/graphviz-dot-mode.el
 ;;; graphviz-dot-mode.el --- Mode for the dot-language used by graphviz (att).

 ;; Copyright (C) 2002 - 2005 Pieter Pareit <pieter.pareit@scarlet.be>

 ;; This program is free software; you can redistribute it and/or
 ;; modify it under the terms of the GNU General Public License as
 ;; published by the Free Software Foundation; either version 2 of
 ;; the License, or (at your option) any later version.

 ;; This program is distributed in the hope that it will be
 ;; useful, but WITHOUT ANY WARRANTY; without even the implied
 ;; warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 ;; PURPOSE.  See the GNU General Public License for more details.

 ;; You should have received a copy of the GNU General Public
 ;; License along with this program; if not, write to the Free
 ;; Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 ;; MA 02111-1307 USA

 ;; Authors: Pieter Pareit <pieter.pareit@scarlet.be>
 ;;          Rubens Ramos <rubensr AT users.sourceforge.net>
 ;; Maintainer: Pieter Pareit <pieter.pareit@planetinternet.be>
 ;; Homepage: http://users.skynet.be/ppareit/projects/graphviz-dot-mode/graphviz-dot-mode.html
 ;; Created: 28 Oct 2002
 ;; Last modified: 15 Feb 2005
 ;; Version: 0.3.3
 ;; Keywords: mode dot dot-language dotlanguage graphviz graphs att

 ;;; Commentary:
 ;; Use this mode for editing files in the dot-language (www.graphviz.org and
 ;; http://www.research.att.com/sw/tools/graphviz/).
 ;;
 ;; To use graphviz-dot-mode, add 
 ;; (load-file "PATH_TO_FILE/graphviz-dot-mode.el") 
 ;; to your ~/.emacs(.el) or ~/.xemacs/init.el
 ;;
 ;; The graphviz-dot-mode will do font locking, indentation, preview of graphs
 ;; and eases compilation/error location. There is support for both GNU Emacs
 ;; and XEmacs.
 ;;
 ;; Font locking is automatic, indentation uses the same commands as
 ;; other modes, tab, M-j and C-M-q.  Insertion of comments uses the
 ;; same commands as other modes, M-; .  You can compile a file using
 ;; M-x compile or C-c c, after that M-x next-error will also work.
 ;; There is support for viewing an generated image with C-c p.

 ;;; Todo:
 ;; * cleanup the mess of graphviz-dot-compilation-parse-errors
 ;; * electric indentation is fundamentally broken, because 
 ;;   {...} are also used for record nodes. You could argue, I suppose, that 
 ;;   many diagrams don't need those, but it would be worth having a note (and 
 ;;   it makes sense that the default is now for electric indentation to be 
 ;;   off).

 ;;; History:

 ;; Version 0.3.4 bug fixes
 ;; 24/02/2005: * fixed a bug in graphviz-dot-preview
 ;; Version 0.3.3 bug fixes
 ;; 13/02/2005: Reuben Thomas <rrt AT sc3d.org>
 ;;             * add graphviz-dot-indent-width
 ;; Version 0.3.2 bug fixes
 ;; 25/03/2004: Rubens Ramos <rubensr AT users.sourceforge.net>
 ;;             * semi-colons and brackets are added when electric
 ;;               behaviour is disabled.
 ;;             * electric characters do not behave electrically inside
 ;;               comments or strings.
 ;;             * default for electric-braces is disabled now (makes more
 ;;               sense I guess).
 ;;             * using read-from-minibuffer instead of read-shell-command
 ;;               for emacs.
 ;;             * Fixed test for easymenu, so that it works on older
 ;;               versions of XEmacs.
 ;;             * Fixed indentation error when trying to indent last brace
 ;;               of an empty graph.
 ;;             * region-active-p does not exist in emacs (21.2 at least),
 ;;               so removed from code
 ;;             * Added uncomment menu option
 ;; Version 0.3.1 bug fixes
 ;; 03/03/2004: * backward-word needs argument for older emacs
 ;; Version 0.3 added features and fixed bugs
 ;; 10/01/2004: fixed a bug in graphviz-dot-indent-graph
 ;; 08/01/2004: Rubens Ramos <rubensr AT users.sourceforge.net>
 ;;             * added customization support
 ;;             * Now it works on XEmacs and Emacs
 ;;             * Added support to use an external Viewer
 ;;             * Now things do not break when dot mode is entered
 ;;               when there is no buffer name, but the side effect is
 ;;               that in this case, the compilation command is not
 ;;               correct.
 ;;             * Preview works on XEmacs and emacs.
 ;;             * Electric indentation on newline
 ;;             * Minor changes to indentation
 ;;             * Added keyword completion (but could be A LOT better)
 ;;             * There are still a couple of ugly hacks. Look for 'RR'.
 ;; Version 0.2 added features
 ;; 11/11/2002: added preview support.
 ;; 10/11/2002: indent a graph or subgraph at once with C-M-q.
 ;; 08/11/2002: relaxed rules for indentation, the may now be extra chars
 ;;             after beginning of graph (comment's for example).
 ;; Version 0.1.2 bug fixes and naming issues
 ;; 06/11/2002: renamed dot-font-lock-defaults to dot-font-lock-keywords.
 ;;             added some documentation to dot-colors.
 ;;             provided a much better way to handle my max-specpdl-size
 ;;             problem.
 ;;             added an extra autoload cookie (hope this helps, as I don't
 ;;             yet use autoload myself)
 ;; Version 0.1.1 bug fixes
 ;; 06/11/2002: added an missing attribute, for font-locking to work.
 ;;             fixed the regex generating, so that it only recognizes
 ;;             whole words
 ;; 05/11/2002: there can now be extra white space chars after an '{'.
 ;; 04/11/2002: Why I use max-specpdl-size is now documented, and old value
 ;;             gets restored.
 ;; Version 0.1 initial release
 ;; 02/11/2002: implemented parser for *compilation* of a .dot file.
 ;; 01/11/2002: implemented compilation of an .dot file.
 ;; 31/10/2002: added syntax-table to the mode.
 ;; 30/10/2002: implemented indentation code.
 ;; 29/10/2002: implemented all of font-lock.
 ;; 28/10/2002: derived graphviz-dot-mode from fundamental-mode, started 
 ;;             implementing font-lock.

 ;;; Code:

 (defconst graphviz-dot-mode-version "0.3.3"
   "Version of `graphviz-dot-mode.el'.")

 (defgroup graphviz nil
   "Major mode for editing Graphviz Dot files"
   :group 'tools)

 (defun graphviz-dot-customize ()
   "Run \\[customize-group] for the `graphviz' group."
   (interactive)
   (customize-group 'graphviz))

 (defvar graphviz-dot-mode-abbrev-table nil
   "Abbrev table in use in Graphviz Dot mode buffers.")
 (define-abbrev-table 'graphviz-dot-mode-abbrev-table ())

 (defcustom graphviz-dot-dot-program "dot"
   "*Location of the dot program. This is used by `compile'."
   :type 'string
   :group 'graphviz)

 (defcustom graphviz-dot-view-command "doted %s"
   "*External program to run on the buffer. You can use `%s' in this string,
 and it will be substituted by the buffer name."
   :type 'string
   :group 'graphviz)

 (defcustom graphviz-dot-view-edit-command nil
   "*Whether to allow the user to edit the command to run an external
 viewer."
   :type 'boolean
   :group 'graphviz)

 (defcustom graphviz-dot-save-before-view t
   "*If not nil, M-x graphviz-dot-view saves the current buffer before running
 the command."
   :type 'boolean
   :group 'graphviz)

 (defcustom graphviz-dot-auto-indent-on-newline t
   "*If not nil, `electric-graphviz-dot-terminate-line' is executed in a line is terminated."
   :type 'boolean
   :group 'graphviz)

 (defcustom graphviz-dot-indent-width default-tab-width
   "*Indentation width in Graphviz Dot mode buffers."
   :type 'integer
   :group 'graphviz)

 (defcustom graphviz-dot-auto-indent-on-braces nil
   "*If not nil, `electric-graphviz-dot-open-brace' and `electric-graphviz-dot-close-brace' are executed when { or } are typed"
   :type 'boolean
   :group 'graphviz)

 (defcustom graphviz-dot-auto-indent-on-semi t
   "*If not nil, `electric-graphviz-dot-semi' is executed when semicolon is typed"
   :type 'boolean
   :group 'graphviz)

 (defcustom graphviz-dot-preview-extension "png"
   "*The extension to use for the compilation and preview commands. The format
 for the compilation command is 
 `dot -T<extension> file.dot > file.<extension>'."
   :type 'string
   :group 'graphviz)

 (defcustom graphviz-dot-toggle-completions nil
   "*Non-nil means that repeated use of \
 \\<graphviz-dot-mode-map>\\[graphviz-dot-complete-word] will toggle the possible
 completions in the minibuffer.  Normally, when there is more than one possible
 completion, a buffer will display all completions."
   :type 'boolean
   :group 'graphviz)

 (defcustom graphviz-dot-delete-completions nil
   "*Non-nil means that the completion buffer is automatically deleted when a
 key is pressed."
   :type 'boolean
   :group 'graphviz)

 (defcustom graphviz-dot-attr-keywords 
   '("graph" "digraph" "subgraph" "node" "edge" "strict" "rankdir"
     "size" "page" "Damping" "Epsilon" "URL" "arrowhead" "arrowsize"
     "arrowtail" "bb" "bgcolor" "bottomlabel" "center" "clusterrank"
     "color" "comment" "compound" "concentrate" "constraint" "decorate"
     "dim" "dir" "distortion" "fillcolor" "fixedsize" "fontcolor"
     "fontname" "fontpath" "fontsize" "group" "headURL" "headlabel"
     "headport" "height" "label" "labelangle" "labeldistance" "labelfloat"
     "labelfontcolor" "labelfontname" "labelfontsize" "labeljust"
     "labelloc" "layer" "layers" "len" "lhead" "lp" "ltail" "margin"
     "maxiter" "mclimit" "minlen" "model" "nodesep" "normalize" "nslimit"
     "nslimit1" "ordering" "orientation" "overlap" "pack" "pagedir"
     "pencolor" "peripheries" "pin" "pos" "quantum" "rank" "ranksep"
     "ratio" "rects" "regular" "remincross" "rotate" "samehead" "sametail"
     "samplepoint" "searchsize" "sep" "shape" "shapefile" "showboxes"
     "sides" "skew" "splines" "start" "style" "stylesheet" "tailURL"
     "taillabel" "tailport" "toplabel" "vertices" "voro_margin" "weight"
     "z")
   "*Keywords for attribute names in a graph. This is used by the auto
 completion code. The actual completion tables are built when the mode
 is loaded, so changes to this are not immediately visible."
   :type '(repeat (string :tag "Keyword"))
   :group 'graphviz)

 (defcustom graphviz-dot-value-keywords 
   '("true" "false" "normal" "inv" "dot" "invdot" "odot" "invodot"
     "none" "tee" "empty" "invempty" "diamond" "odiamond" "box" "obox"
     "open" "crow" "halfopen" "local" "global" "none" "forward" "back"
     "both" "none" "BL" "BR" "TL" "TR" "RB" "RT" "LB" "LT" ":n" ":ne" ":e"
     ":se" ":s" ":sw" ":w" ":nw" "same" "min" "source" "max" "sink" "LR"
     "box" "polygon" "ellipse" "circle" "point" "egg" "triangle"
     "plaintext" "diamond" "trapezium" "parallelogram" "house" "hexagon"
     "octagon" "doublecircle" "doubleoctagon" "tripleoctagon" "invtriangle"
     "invtrapezium" "invhouse" "Mdiamond" "Msquare" "Mcircle" "record"
     "Mrecord" "dashed" "dotted" "solid" "invis" "bold" "filled"
     "diagonals" "rounded" ) 
   "*Keywords for attribute values. This is used by the auto completion
 code. The actual completion tables are built when the mode is loaded,
 so changes to this are not immediately visible."
   :type '(repeat (string :tag "Keyword")) 
   :group 'graphviz)

 ;;; Font-locking:
 (defvar graphviz-dot-colors-list
   '(aliceblue antiquewhite antiquewhite1 antiquewhite2
         antiquewhite3 antiquewhite4 aquamarine aquamarine1
         aquamarine2 aquamarine3 aquamarine4 azure azure1
         azure2 azure3 azure4 beige bisque bisque1 bisque2
         bisque3 bisque4 black blanchedalmond blue blue1
         blue2 blue3 blue4 blueviolet brown brown1 brown2
         brown3 brown4 burlywood burlywood1 burlywood2
         burlywood3 burlywood4 cadetblue cadetblue1
         cadetblue2 cadetblue3 cadetblue4 chartreuse
         chartreuse1 chartreuse2 chartreuse3 chartreuse4
         chocolate chocolate1 chocolate2 chocolate3 chocolate4
         coral coral1 coral2 coral3 coral4 cornflowerblue
         cornsilk cornsilk1 cornsilk2 cornsilk3 cornsilk4
         crimson cyan cyan1 cyan2 cyan3 cyan4 darkgoldenrod
         darkgoldenrod1 darkgoldenrod2 darkgoldenrod3
         darkgoldenrod4 darkgreen darkkhaki darkolivegreen
         darkolivegreen1 darkolivegreen2 darkolivegreen3
         darkolivegreen4 darkorange darkorange1 darkorange2
         darkorange3 darkorange4 darkorchid darkorchid1
         darkorchid2 darkorchid3 darkorchid4 darksalmon
         darkseagreen darkseagreen1 darkseagreen2
         darkseagreen3 darkseagreen4 darkslateblue
         darkslategray darkslategray1 darkslategray2
         darkslategray3  darkslategray4 darkslategrey
         darkturquoise darkviolet deeppink deeppink1
         deeppink2 deeppink3 deeppink4 deepskyblue
         deepskyblue1 deepskyblue2 deepskyblue3 deepskyblue4
         dimgray dimgrey  dodgerblue dodgerblue1 dodgerblue2
         dodgerblue3  dodgerblue4 firebrick firebrick1
         firebrick2 firebrick3 firebrick4 floralwhite
         forestgreen gainsboro ghostwhite gold gold1 gold2
         gold3 gold4 goldenrod goldenrod1 goldenrod2
         goldenrod3 goldenrod4 gray gray0 gray1 gray10 gray100
         gray11 gray12 gray13 gray14 gray15 gray16 gray17
         gray18 gray19 gray2 gray20 gray21 gray22 gray23
         gray24 gray25 gray26 gray27 gray28 gray29 gray3
         gray30 gray31 gray32 gray33 gray34 gray35 gray36
         gray37 gray38 gray39 gray4 gray40 gray41 gray42
         gray43 gray44 gray45 gray46 gray47 gray48 gray49
         gray5 gray50 gray51 gray52 gray53 gray54 gray55
         gray56 gray57 gray58 gray59 gray6 gray60 gray61
         gray62 gray63 gray64 gray65 gray66 gray67 gray68
         gray69 gray7 gray70 gray71 gray72 gray73 gray74
         gray75 gray76 gray77 gray78 gray79 gray8 gray80
         gray81 gray82 gray83 gray84 gray85 gray86 gray87
         gray88 gray89 gray9 gray90 gray91 gray92 gray93
         gray94 gray95 gray96 gray97 gray98 gray99 green
         green1 green2 green3 green4 greenyellow grey grey0
         grey1 grey10 grey100 grey11 grey12 grey13 grey14
         grey15 grey16 grey17 grey18 grey19 grey2 grey20
         grey21 grey22 grey23 grey24 grey25 grey26 grey27
         grey28 grey29 grey3 grey30 grey31 grey32 grey33
         grey34 grey35 grey36 grey37 grey38 grey39 grey4
         grey40 grey41 grey42 grey43 grey44 grey45 grey46
         grey47 grey48 grey49 grey5 grey50 grey51 grey52
         grey53 grey54 grey55 grey56 grey57 grey58 grey59
         grey6 grey60 grey61 grey62 grey63 grey64 grey65
         grey66 grey67 grey68 grey69 grey7 grey70 grey71
         grey72 grey73 grey74 grey75 grey76 grey77 grey78
         grey79 grey8 grey80 grey81 grey82 grey83 grey84
         grey85 grey86 grey87 grey88 grey89 grey9 grey90
         grey91 grey92 grey93 grey94 grey95 grey96 grey97
         grey98 grey99 honeydew honeydew1 honeydew2 honeydew3
         honeydew4 hotpink hotpink1 hotpink2 hotpink3 hotpink4
         indianred indianred1 indianred2 indianred3 indianred4
         indigo ivory ivory1 ivory2 ivory3 ivory4 khaki khaki1
         khaki2 khaki3 khaki4 lavender lavenderblush
         lavenderblush1 lavenderblush2 lavenderblush3
         lavenderblush4 lawngreen lemonchiffon lemonchiffon1
         lemonchiffon2 lemonchiffon3 lemonchiffon4 lightblue
         lightblue1 lightblue2 lightblue3 lightblue4
         lightcoral lightcyan lightcyan1 lightcyan2 lightcyan3
         lightcyan4 lightgoldenrod lightgoldenrod1
         lightgoldenrod2 lightgoldenrod3 lightgoldenrod4
         lightgoldenrodyellow lightgray lightgrey lightpink
         lightpink1 lightpink2 lightpink3 lightpink4
         lightsalmon lightsalmon1 lightsalmon2 lightsalmon3
         lightsalmon4 lightseagreen lightskyblue lightskyblue1
         lightskyblue2 lightskyblue3 lightskyblue4
         lightslateblue lightslategray lightslategrey
         lightsteelblue lightsteelblue1 lightsteelblue2
         lightsteelblue3 lightsteelblue4 lightyellow
         lightyellow1 lightyellow2 lightyellow3 lightyellow4
         limegreen linen magenta magenta1 magenta2 magenta3
         magenta4 maroon maroon1 maroon2 maroon3 maroon4
         mediumaquamarine mediumblue  mediumorchid
         mediumorchid1 mediumorchid2 mediumorchid3
         mediumorchid4 mediumpurple mediumpurple1
         mediumpurple2 mediumpurple3 mediumpurple4
         mediumseagreen mediumslateblue mediumspringgreen
         mediumturquoise mediumvioletred midnightblue
         mintcream mistyrose mistyrose1 mistyrose2 mistyrose3
         mistyrose4 moccasin navajowhite navajowhite1
         navajowhite2 navajowhite3 navajowhite4 navy navyblue
         oldlace olivedrab olivedrap olivedrab1 olivedrab2
         olivedrap3 oragne palegoldenrod palegreen palegreen1
         palegreen2 palegreen3 palegreen4 paleturquoise
         paleturquoise1 paleturquoise2 paleturquoise3
         paleturquoise4 palevioletred palevioletred1
         palevioletred2 palevioletred3 palevioletred4
         papayawhip peachpuff peachpuff1 peachpuff2
         peachpuff3 peachpuff4 peru pink pink1 pink2 pink3
         pink4 plum plum1 plum2 plum3 plum4 powderblue
         purple purple1 purple2 purple3 purple4 red red1 red2
         red3 red4 rosybrown rosybrown1 rosybrown2 rosybrown3
         rosybrown4 royalblue royalblue1 royalblue2 royalblue3
         royalblue4 saddlebrown salmon salmon1 salmon2 salmon3
         salmon4 sandybrown seagreen seagreen1 seagreen2
         seagreen3 seagreen4 seashell seashell1 seashell2
         seashell3 seashell4 sienna sienna1 sienna2 sienna3
         sienna4 skyblue skyblue1 skyblue2 skyblue3 skyblue4
         slateblue slateblue1 slateblue2 slateblue3 slateblue4
         slategray slategray1 slategray2 slategray3 slategray4
         slategrey snow snow1 snow2 snow3 snow4 springgreen
         springgreen1 springgreen2 springgreen3 springgreen4
         steelblue steelblue1 steelblue2 steelblue3 steelblue4
         tan tan1 tan2 tan3 tan4 thistle thistle1 thistle2
         thistle3 thistle4 tomato tomato1 tomato2 tomato3
         tomato4 transparent turquoise turquoise1 turquoise2
         turquoise3 turquoise4 violet violetred violetred1
         violetred2 violetred3 violetred4 wheat wheat1 wheat2
         wheat3 wheat4 white whitesmoke yellow yellow1 yellow2
         yellow3 yellow4 yellowgreen)
   "Possible color constants in the dot language.
 The list of constant is available at http://www.research.att.com/~erg/graphviz\
 /info/colors.html")


 (defvar graphviz-dot-color-keywords
   (mapcar 'symbol-name graphviz-dot-colors-list))

 (defvar graphviz-attr-keywords
   (mapcar '(lambda (elm) (cons elm 0)) graphviz-dot-attr-keywords))

 (defvar graphviz-value-keywords
   (mapcar '(lambda (elm) (cons elm 0)) graphviz-dot-value-keywords))

 (defvar graphviz-color-keywords
   (mapcar '(lambda (elm) (cons elm 0)) graphviz-dot-color-keywords))

 ;;; Key map
 (defvar graphviz-dot-mode-map ()
   "Keymap used in Graphviz Dot mode.")

 (if graphviz-dot-mode-map
     ()
   (let ((map (make-sparse-keymap)))
     (define-key map "\r"       'electric-graphviz-dot-terminate-line)
     (define-key map "{"        'electric-graphviz-dot-open-brace)
     (define-key map "}"        'electric-graphviz-dot-close-brace)
     (define-key map ";"        'electric-graphviz-dot-semi)
     (define-key map "\M-\t"    'graphviz-dot-complete-word)
     (define-key map "\C-\M-q"  'graphviz-dot-indent-graph)
     (define-key map "\C-cp"    'graphviz-dot-preview)
     (define-key map "\C-cc"    'compile)
     (define-key map "\C-cv"    'graphviz-dot-view)
     (define-key map "\C-c\C-c" 'comment-region)
     (define-key map "\C-c\C-u" 'graphviz-dot-uncomment-region)
     (setq graphviz-dot-mode-map map)
     ))

 ;;; Syntax table
 (defvar graphviz-dot-mode-syntax-table nil
   "Syntax table for `graphviz-dot-mode'.")

 (if graphviz-dot-mode-syntax-table
     ()
   (let ((st (make-syntax-table)))
     (modify-syntax-entry ?/  ". 124b" st)
     (modify-syntax-entry ?*  ". 23"   st)
     (modify-syntax-entry ?\n "> b"    st)
     (modify-syntax-entry ?=  "."      st)
     (modify-syntax-entry ?_  "_"      st)
     (modify-syntax-entry ?-  "_"      st)
     (modify-syntax-entry ?>  "."      st)
     (modify-syntax-entry ?[  "("      st)
     (modify-syntax-entry ?]  ")"      st)
     (modify-syntax-entry ?\" "\""     st)
     (setq graphviz-dot-mode-syntax-table st)
   ))

 (defvar graphviz-dot-font-lock-keywords
   `(("\\(:?di\\|sub\\)?graph \\(\\sw+\\)"
      (2 font-lock-function-name-face))
     (,(regexp-opt graphviz-dot-value-keywords 'words)
      . font-lock-reference-face)
     ;; to build the font-locking for the colors,
     ;; we need more room for max-specpdl-size,
     ;; after that we take the list of symbols,
     ;; convert them to a list of strings, and make
     ;; an optimized regexp from them
     (,(let ((max-specpdl-size (max max-specpdl-size 1200)))
   (regexp-opt graphviz-dot-color-keywords))
      . font-lock-string-face)
     (,(concat
	(regexp-opt graphviz-dot-attr-keywords 'words)
	"[ \\t\\n]*=")
      ;; RR - ugly, really, but I dont know why xemacs does not work
      ;; if I change the next car to "1"...
      (0 font-lock-variable-name-face)))
   "Keyword highlighting specification for `graphviz-dot-mode'.")

 ;;;###autoload
 (defun graphviz-dot-mode ()
   "Major mode for the dot language. \\<graphviz-dot-mode-map> 
 TAB indents for graph lines. 

 \\[graphviz-dot-indent-graph]\t- Indentaion function.
 \\[graphviz-dot-preview]\t- Previews graph in a buffer.
 \\[graphviz-dot-view]\t- Views graph in an external viewer.
 \\[graphviz-dot-indent-line]\t- Indents current line of code.
 \\[graphviz-dot-complete-word]\t- Completes the current word.
 \\[electric-graphviz-dot-terminate-line]\t- Electric newline.
 \\[electric-graphviz-dot-open-brace]\t- Electric open braces.
 \\[electric-graphviz-dot-close-brace]\t- Electric close braces.
 \\[electric-graphviz-dot-semi]\t- Electric semi colons.

 Variables specific to this mode:

   graphviz-dot-dot-program            (default `dot')
	Location of the dot program.
   graphviz-dot-view-command           (default `doted %s')
	Command to run when `graphviz-dot-view' is executed.
   graphviz-dot-view-edit-command      (default nil)
	If the user should be asked to edit the view command.
   graphviz-dot-save-before-view       (default t)
	Automatically save current buffer berore `graphviz-dot-view'.
   graphviz-dot-preview-extension      (default `png')
	File type to use for `graphviz-dot-preview'.
   graphviz-dot-auto-indent-on-newline (default t)
	Whether to run `electric-graphviz-dot-terminate-line' when 
	newline is entered.
   graphviz-dot-auto-indent-on-braces (default t)
	Whether to run `electric-graphviz-dot-open-brace' and
	`electric-graphviz-dot-close-brace' when braces are 
	entered.
   graphviz-dot-auto-indent-on-semi (default t)
	Whether to run `electric-graphviz-dot-semi' when semi colon
	is typed.
   graphviz-dot-toggle-completions  (default nil)
	If completions should be displayed in the buffer instead of a
	completion buffer when \\[graphviz-dot-complete-word] is
	pressed repeatedly.

 This mode can be customized by running \\[graphviz-dot-customize].

 Turning on Graphviz Dot mode calls the value of the variable 
 `graphviz-dot-mode-hook' with no args, if that value is non-nil."
   (interactive)
   (kill-all-local-variables)
   (use-local-map graphviz-dot-mode-map)
   (setq major-mode 'graphviz-dot-mode)
   (setq mode-name "dot")
   (setq local-abbrev-table graphviz-dot-mode-abbrev-table)
   (set-syntax-table graphviz-dot-mode-syntax-table)
   (set (make-local-variable 'indent-line-function) 'graphviz-dot-indent-line)
   (set (make-local-variable 'comment-start) "//")
   (set (make-local-variable 'comment-start-skip) "/\\*+ *\\|//+ *")
   (set (make-local-variable 'font-lock-defaults) 
	'(graphviz-dot-font-lock-keywords))
   ;; RR - If user is running this in the scratch buffer, there is no
   ;; buffer file name...
   (if (buffer-file-name)
       (set (make-local-variable 'compile-command) 
	(concat graphviz-dot-dot-program
		" -T" graphviz-dot-preview-extension " "
		buffer-file-name
		" > "
		(file-name-sans-extension
                 buffer-file-name)
		"." graphviz-dot-preview-extension)))
   (set (make-local-variable 'compilation-parse-errors-function)
	'graphviz-dot-compilation-parse-errors)
   (if dot-menu
       (easy-menu-add dot-menu))
   (run-hooks 'graphviz-dot-mode-hook)
   )

 ;;;; Menu definitions

 (defvar dot-menu nil
   "Menu for Graphviz Dot Mode.
 This menu will get created automatically if you have the `easymenu'
 package. Note that the latest X/Emacs releases contain this package.")

 (and (condition-case nil
          (require 'easymenu)
	(error nil))
      (easy-menu-define
       dot-menu graphviz-dot-mode-map "Graphviz Mode menu"
       '("Graphviz"
         ["Indent Graph"       graphviz-dot-indent-graph     t]
         ["Comment Out Region" comment-region                (mark)]
         ["Uncomment Region"   graphviz-dot-uncomment-region (mark)]
         "-"
         ["Compile"            compile                       t]
         ["Preview"            graphviz-dot-preview        
          (and (buffer-file-name)
               (not (buffer-modified-p)))]
         ["External Viewer"    graphviz-dot-view             (buffer-file-name)]
         "-"
         ["Customize..."       graphviz-dot-customize        t]
         )))

 ;;;; Compilation

 ;; note on graphviz-dot-compilation-parse-errors:
 ;;  It would nicer if we could just use compilation-error-regexp-alist
 ;;  to do that, 3 options:
 ;;   - still write dot-compilation-parse-errors, don't build
 ;;     a return list, but modify the *compilation* buffer
 ;;     in a way compilation-error-regexp-alist recognizes the
 ;;     format.
 ;;     to do that, I should globally change compilation-parse-function
 ;;     to this function, and call the old value of comp..-parse-fun..
 ;;     to provide the return value.
 ;;     two drawbacks are that, every compilation would be run through
 ;;     this function (performance) and that in autoload there would
 ;;     be a chance that this function would not yet be known.
 ;;   - let the compilation run through a filter that would
 ;;     modify the output of dot or neato:
 ;;     dot -Tpng input.dot | filter
 ;;     drawback: ugly, extra work for user, extra decency ...
 ;;               no-option
 ;;   - modify dot and neato !!! (PP:15/02/2005 seems to have happend,
 ;;                                       so version 0.4.0 should clean this mess up!)
 (defun graphviz-dot-compilation-parse-errors (limit-search find-at-least)
   "Parse the current buffer for dot errors.
 See variable `compilation-parse-errors-functions' for interface."
   (interactive)
   (save-excursion
     (set-buffer "*compilation*")
     (goto-char (point-min))
     (setq compilation-error-list nil)
     (let (buffer-of-error)
       (while (not (eobp))
   (cond
    ((looking-at "^dot\\( -[^ ]+\\)* \\(.*\\)")
     (setq buffer-of-error (find-file-noselect
          (buffer-substring-no-properties
           (nth 4 (match-data t))
           (nth 5 (match-data t))))))
    ((looking-at ".*:.*line \\([0-9]+\\)")
     (let ((line-of-error
      (string-to-number (buffer-substring-no-properties
             (nth 2 (match-data t))
             (nth 3 (match-data t))))))
       (setq compilation-error-list
       (cons
	(cons
         (point-marker)
         (save-excursion
           (set-buffer buffer-of-error)
           (goto-line line-of-error)
           (beginning-of-line)
           (point-marker)))
	compilation-error-list))))
     (t t))
   (forward-line 1)) )))

 ;;;;
 ;;;; Indentation
 ;;;;
 (defun graphviz-dot-uncomment-region (begin end)
	 "Uncomments a region of code."
	 (interactive "r")
	 (comment-region begin end '(4)))

 (defun graphviz-dot-indent-line ()
   "Indent current line of dot code."
   (interactive)
   (if (bolp)
       (graphviz-dot-real-indent-line)
     (save-excursion
       (graphviz-dot-real-indent-line))))
        
 (defun graphviz-dot-real-indent-line ()
   "Indent current line of dot code."
   (beginning-of-line)
   (cond
    ((bobp)
     ;; simple case, indent to 0
     (indent-line-to 0))
    ((looking-at "^[ \t]*}[ \t]*$")
     ;; block closing, deindent relative to previous line
     (indent-line-to (save-excursion
                       (forward-line -1)
                       (max 0 (- (current-indentation) graphviz-dot-indent-width)))))
    ;; other cases need to look at previous lines
    (t
     (indent-line-to (save-excursion
                       (forward-line -1)
                       (cond
			((looking-at "\\(^.*{[^}]*$\\)")
                         ;; previous line opened a block
                         ;; indent to that line
                         (+ (current-indentation) graphviz-dot-indent-width))
			((and (not (looking-at ".*\\[.*\\].*"))
                              (looking-at ".*\\[.*")) ; TODO:PP : can be 1 regex
                         ;; previous line started filling
                         ;; attributes, intend to that start
                         (search-forward "[")
                         (current-column))
			((and (not (looking-at ".*\\[.*\\].*"))
                              (looking-at ".*\\].*")) ; TODO:PP : "
                         ;; previous line stopped filling
                         ;; attributes, find the line that started
                         ;; filling them and indent to that line
                         (while (or (looking-at ".*\\[.*\\].*")
                                    (not (looking-at ".*\\[.*"))) ; TODO:PP : "
                           (forward-line -1))
                         (current-indentation))
			(t
                         ;; default case, indent the
                         ;; same as previous line
                         (current-indentation)) ))) )))

 (defun graphviz-dot-indent-graph ()
   "Indent the graph/digraph/subgraph where point is at.
 This will first teach the beginning of the graph were point is at, and
 then indent this and each subgraph in it."
   (interactive)
   (save-excursion
     ;; position point at start of graph
     (while (not (or (looking-at "\\(^.*{[^}]*$\\)") (bobp)))
       (forward-line -1))
     ;; bracket { one +; bracket } one -
     (let ((bracket-count 0))
       (while
           (progn
             (cond
              ;; update bracket-count
              ((looking-at "\\(^.*{[^}]*$\\)")
               (setq bracket-count (+ bracket-count 1)))
              ;; update bracket-count
              ((looking-at "^[ \t]*}[ \t]*$")
               (setq bracket-count (- bracket-count 1))))
             ;; indent this line and move on
             (graphviz-dot-indent-line)
             (forward-line 1)
             ;; as long as we are not completed or at end of buffer
             (and (> bracket-count 0) (not (eobp))))))))
     
 ;;;;
 ;;;; Electric indentation
 ;;;;
 (defun graphviz-dot-comment-or-string-p ()
   (let ((state (parse-partial-sexp (point-min) (point))))
      (or (nth 4 state) (nth 3 state))))

 (defun graphviz-dot-newline-and-indent ()
   (save-excursion
     (beginning-of-line)
     (skip-chars-forward " \t")
     (graphviz-dot-indent-line))
   (delete-horizontal-space)
   (newline)
   (graphviz-dot-indent-line))

 (defun electric-graphviz-dot-terminate-line ()
   "Terminate line and indent next line."
   (interactive)
   (if graphviz-dot-auto-indent-on-newline
       (graphviz-dot-newline-and-indent)
     (newline)))

 (defun electric-graphviz-dot-open-brace ()
   "Terminate line and indent next line."
   (interactive)
   (insert "{")
   (if (and graphviz-dot-auto-indent-on-braces
            (not (graphviz-dot-comment-or-string-p)))
       (graphviz-dot-newline-and-indent)))

 (defun electric-graphviz-dot-close-brace ()
   "Terminate line and indent next line."
   (interactive)
   (insert "}")
   (if (and graphviz-dot-auto-indent-on-braces
            (not (graphviz-dot-comment-or-string-p)))
       (progn
         (save-excursion
           (beginning-of-line)
           (skip-chars-forward " \t")
           (graphviz-dot-indent-line))
         (newline)
         (graphviz-dot-indent-line))))

 (defun electric-graphviz-dot-semi ()
   "Terminate line and indent next line."
   (interactive)
   (insert ";")
   (if (and graphviz-dot-auto-indent-on-semi
            (not (graphviz-dot-comment-or-string-p)))
       (graphviz-dot-newline-and-indent)))

 ;;;;
 ;;;; Preview
 ;;;;
 (defun graphviz-dot-preview ()
   "Shows an example of the current dot file in an emacs buffer.
 This assumes that we are running GNU Emacs or XEmacs under a windowing system.
 See `image-file-name-extensions' for customizing the files that can be
 loaded in GNU Emacs, and `image-formats-alist' for XEmacs."
   (interactive)
   ;; unsafe to compile ourself, ask it to the user
   (if (buffer-modified-p)
       (message "Buffer needs to be compiled.")
     (if (string-match "XEmacs" emacs-version)
         ;; things are easier in XEmacs...
         (find-file-other-window (concat (file-name-sans-extension
					  buffer-file-name)
					 "." graphviz-dot-preview-extension))
       ;; run through all the extensions for images
       (let ((l image-file-name-extensions))
         (while
             (let ((f (concat (file-name-sans-extension (buffer-file-name))
                              "."
                              (car l))))
               ;; see if a file matches, might be best also to check
               ;; if file is up to date TODO:PP
               (if (file-exists-p f)
                   (progn (auto-image-file-mode 1)
                          ;; OK, this is ugly, I would need to 
                          ;; know how I can reload a file in an existing buffer
                          (if (get-buffer "*preview*")
                              (kill-buffer "*preview*"))
                          (set-buffer (find-file-noselect f))
                          (rename-buffer "*preview*")
                          (display-buffer (get-buffer "*preview*"))
                          ;; stop iterating
                          '())
                 ;; will stop iterating when l is nil
                 (setq l (cdr l)))))
       ;; each extension tested and nothing found, let user know
       (when (eq l '())
         (message "No image found."))))))

 ;;;;
 ;;;; View
 ;;;;
 (defun graphviz-dot-view ()
   "Runs an external viewer. This creates an external process every time it
 is executed. If `graphviz-dot-save-before-view' is set, the current
 buffer is saved before the command is executed."
   (interactive)
   (let ((cmd (if graphviz-dot-view-edit-command
                  (if (string-match "XEmacs" emacs-version)
                      (read-shell-command "View command: " 
                                          (format graphviz-dot-view-command
                                                  (buffer-file-name)))
                    (read-from-minibuffer "View command: " 
                                          (format graphviz-dot-view-command
                                                  (buffer-file-name))))
		(format graphviz-dot-view-command (buffer-file-name)))))
     (if graphviz-dot-save-before-view 
         (save-buffer))
     (setq novaproc (start-process-shell-command
                     (downcase mode-name) nil cmd))
     (message (format "Executing `%s'..." cmd))))

 ;;;;
 ;;;; Completion
 ;;;;
 (defvar graphviz-dot-str nil)
 (defvar graphviz-dot-all nil)
 (defvar graphviz-dot-pred nil)
 (defvar graphviz-dot-buffer-to-use nil)
 (defvar graphviz-dot-flag nil)

 (defun graphviz-dot-get-state ()
   "Returns the syntax state of the current point."
   (let ((state (parse-partial-sexp (point-min) (point))))
     (cond
      ((nth 4 state) 'comment)
      ((nth 3 state) 'string)
      ((not (nth 1 state)) 'out)
      (t (save-excursion
           (skip-chars-backward "^[,=\\[]{};")
           (backward-char)
           (cond 
            ((looking-at "[\\[,]{};") 'attribute)
            ((looking-at "=") (progn
				(backward-word 1)
				(if (looking-at "[a-zA-Z]*color")
                                    'color
                                  'value)))
            (t 'other)))))))

 (defun graphviz-dot-get-keywords ()
   "Return possible completions for a word"
   (let ((state (graphviz-dot-get-state)))
     (cond
      ((equal state 'comment)   ())
      ((equal state 'string)    ())
      ((equal state 'out)       graphviz-attr-keywords)
      ((equal state 'value)     graphviz-value-keywords)
      ((equal state 'color)     graphviz-color-keywords)
      ((equal state 'attribute) graphviz-attr-keywords)
      (t                        graphviz-attr-keywords))))

 (defvar graphviz-dot-last-word-numb 0)
 (defvar graphviz-dot-last-word-shown nil)
 (defvar graphviz-dot-last-completions nil)

 (defun graphviz-dot-complete-word ()
   "Complete word at current point."
   (interactive)
   (let* ((b (save-excursion (skip-chars-backward "a-zA-Z0-9_") (point)))
          (e (save-excursion (skip-chars-forward "a-zA-Z0-9_") (point)))
          (graphviz-dot-str (buffer-substring b e))
          (allcomp (if (and graphviz-dot-toggle-completions
                            (string= graphviz-dot-last-word-shown 
                                     graphviz-dot-str))
                       graphviz-dot-last-completions
                     (all-completions graphviz-dot-str 
                                      (graphviz-dot-get-keywords))))
          (match (if graphviz-dot-toggle-completions
                     "" (try-completion
                         graphviz-dot-str (mapcar '(lambda (elm)
                                                     (cons elm 0)) allcomp)))))
     ;; Delete old string
     (delete-region b e)
    
     ;; Toggle-completions inserts whole labels
     (if graphviz-dot-toggle-completions
         (progn
           ;; Update entry number in list
           (setq graphviz-dot-last-completions allcomp
                 graphviz-dot-last-word-numb 
                 (if (>= graphviz-dot-last-word-numb (1- (length allcomp)))
                     0
                   (1+ graphviz-dot-last-word-numb)))
           (setq graphviz-dot-last-word-shown 
                 (elt allcomp graphviz-dot-last-word-numb))
           ;; Display next match or same string if no match was found
           (if (not (null allcomp))
               (insert "" graphviz-dot-last-word-shown)
             (insert "" graphviz-dot-str)
             (message "(No match)")))
       ;; The other form of completion does not necessarily do that.
      
       ;; Insert match if found, or the original string if no match
       (if (or (null match) (equal match 't))
           (progn (insert "" graphviz-dot-str)
                  (message "(No match)"))
         (insert "" match))
       ;; Give message about current status of completion
       (cond ((equal match 't)
              (if (not (null (cdr allcomp)))
                  (message "(Complete but not unique)")
		(message "(Sole completion)")))
             ;; Display buffer if the current completion didn't help 
             ;; on completing the label.
             ((and (not (null (cdr allcomp))) (= (length graphviz-dot-str)
                                                 (length match)))
              (with-output-to-temp-buffer "*Completions*"
		(display-completion-list allcomp))
              ;; Wait for a keypress. Then delete *Completion*  window
              (momentary-string-display "" (point))
              (if graphviz-dot-delete-completions
                  (delete-window 
                   (get-buffer-window (get-buffer "*Completions*"))))
              )))))

 ;;;###autoload
 (add-to-list 'auto-mode-alist '("\\.dot\\'" . graphviz-dot-mode))

 ;;; graphviz-dot-mode.el ends here


 #+END_SRC
*** list-processes+.el
 Utilize process-management in emacs. 

 #+BEGIN_SRC elisp :tangle lisp/list-processes+.el
 ;;; list-processes+.el --- Add process management to `list-processes'

 ;; Copyright 2006 Ye Wenbin
 ;;
 ;; Author: wenbinye@163.com
 ;; Time-stamp: <Ye Wenbin 2006-10-15 18:35:43>
 ;; Version: $Id: list-process-mode.el,v 0.0 <2006-10-15 17:13:28> ywb Exp $
 ;; Keywords: 
 ;; X-URL: not distributed yet

 ;; This program is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
 ;; the Free Software Foundation; either version 2, or (at your option)
 ;; any later version.
 ;;
 ;; This program is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;; GNU General Public License for more details.
 ;;
 ;; You should have received a copy of the GNU General Public License
 ;; along with this program; if not, write to the Free Software
 ;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

 ;;; Commentary:

 ;; 

 ;; Put this file into your load-path and the following into your ~/.emacs:
 ;;   (autoload "list-processes+" 'list-processes+
 ;;          "A enhance list processes command" t)

 ;;; Code:

 (provide 'list-processes+)
 (eval-when-compile
   (require 'cl))

 (defvar list-processes-mode-map
   (let ((map (make-sparse-keymap)))
     (define-key map "\C-k" 'list-processes-kill-process)
     (define-key map "\C-m" 'list-processes-goto-buffer)
     (define-key map "G" 'list-processes+)
     (define-key map "S" 'list-processes-sort)
     map)
   "")

 ;;;###autoload
 (defun list-processes+ (&optional query-only)
   ""
   (interactive "P")
   (list-processes query-only)
   (let ((procs (process-list))
         (inhibit-read-only t))
     (if query-only
         (setq procs (remove-if-not 'process-query-on-exit-flag procs)))
     (save-excursion
       (set-buffer (get-buffer "*Process List*"))
       (goto-char (point-min))
       (forward-line 2)
       (while (not (eobp))
         (put-text-property (point)
                            (progn
                              (forward-line 1)
                              (point)) 'process (car procs))
         (setq procs (cdr procs)))
       (list-processes-mode))))

 (define-minor-mode list-processes-mode
   "Add process management to `list-processes'"
   :lighter " LP+"
   :keymap list-processes-mode-map)

 (defun list-processes-sort (&optional reverse)
   ""
   (interactive "P")
   (let ((inhibit-read-only t))
     (save-excursion
       (goto-char (point-min))
       (forward-line 2)
       (sort-lines reverse (point) (point-max)))))

 (defun list-processes-kill-process ()
   ""
   (interactive)
   (let ((proc (get-text-property (point) 'process)))
     (when (and proc
		(y-or-n-p (format "Kill process %s? " (process-name proc))))
       (delete-process proc)
       (list-processes+))))

 (defun list-processes-goto-buffer ()
   ""
   (interactive)
   (let ((proc (get-text-property (point) 'process)))
     (when proc
       (if (and (process-buffer proc)
		(buffer-live-p (process-buffer proc)))
           (switch-to-buffer (process-buffer proc))
         (message "No associate buffer!")))))
 ;;; list-process-mode.el ends here
 #+END_SRC
*** mail-signature.el                                               :ARCHIVE:
 Mail signatures functionality. These days, though, I use snippets for this. 
 #+BEGIN_SRC elisp :tangle lisp/mail-signature.el
 ;;; mail-signature.el -- Add context sensitive signature
 ;;; Copyright (C) 1997 Kevin Davidson
 ;;; Copyright (C) 1985, 1986, 1992 Free Software Foundation, Inc
 
 ;;; Maintainer: tkld
 ;;; Keywords: mail

 ;;; This program is free software; you can redistribute it and/or modify
 ;;; it under the terms of the GNU General Public License as published by
 ;;; the Free Software Foundation; either version 2, or (at your option)
 ;;; any later version.

 ;;; This program is distributed in the hope that it will be useful,
 ;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;;; GNU General Public License for more details.

 ;;; A copy of the GNU General Public License can be obtained from this
 ;;; program's author (send electronic mail to <tkld@cogsci.ed.ac.uk>)
 ;;; or from the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 ;;; Boston, MA 02111-1307, USA.

 ;;; LCD Archive Entry:
 ;;; mail-signature|Kevin Davidson|<tkld@cogsci.ed.ac.uk>
 ;;; |Add context sensitive signature
 ;;; |$Date: 1997/04/18 09:14:51 $|$Revision: 1.7 $|~/packages/mail-signature.el

 ;;; Commentary:

 ;;; This is a reworking of the function mail-signature in sendmail.el
 ;;; (part of the Emacs distribution) to insert a context sensitive signature.
 ;;; Using regular expressions, appropriate signatures can be inserted 
 ;;; for different audiences.
 ;;; Repeated calls removes the current signature from the message and cycles
 ;;; through all applicable signatures.
 ;;; Use with something like this in .emacs:
 ;;; (eval-after-load "sendmail"
 ;;;   (progn
 ;;;     (load "mail-signature")
 ;;;     (setq mail-signature-alist 
 ;;;           (append '(("To" "friend" "-friendly")) mail-signature-alist))))
 ;;; And create a file called ~/.signature-friendly that has a
 ;;; signature appropriate for the user `friend' to receive.
 ;;; If using message-mode (included with Emacs 19.34/GNUS 5.3 or later)
 ;;; (setq message-signature 'mail-signature)

 ;;; Change log:
 ;; $Log: mail-signature.el,v $
 ; Revision 1.7  1997/04/18  09:14:51  tkld
 ; Add change log. Update GPL version and FSF address. Cycle through all
 ; possible signatures, not just toggle between two.
 ;

 ;;; Code:

 (defconst mail-signature-version (substring "$Revision: 1.7 $" 11 -2)
   "$Id: mail-signature.el,v 1.7 1997/04/18 09:14:51 tkld Exp $

 Report bugs to: Kevin Davidson <tkld@cogsci.ed.ac.uk>")


 (defvar mail-signature-last-signature 0
  "Record index of last signature used for repeated calls of mail-signature
 Buffer local")
 (make-variable-buffer-local 'mail-signature-last-signature)

 (defvar mail-signature-base "~/.signature"
   "*The base part of signature filename. 
 Entries from mail-signature-alist will be added to this.")

 (defvar mail-signature-alist
   '(("" "" ""))
   "*List of extensions to add to mail-signature-base to form name of sig file.
 Format is: (HEADER REGEX EXTENSION), where REGEX is a regular expression
 that should match the contents of the mail or news header HEADER.
 The first to match is used. In REGEX, ^ and $ mark the beginning and end
 of just the text in the header, not the whole line.")

 (defun mail-signature (&optional atpoint)
   "Sign letter with context sensitive signature, based on mail-signature-alist.
 Argument ATPOINT says whether to insert signature at point, or at end of
 buffer."
   (interactive "P")
   (save-excursion
     (or atpoint
  (goto-char (point-max)))
     ;; First search for previous signature to delete
     ;; or delete trailing whitespace
     (if (null (search-backward "\n\n-- \n" (point-min) t))
  (progn
    (skip-chars-backward " \t\n")
    (end-of-line)))
     (or atpoint
         (delete-region (point) (point-max)))
     (insert "\n\n-- \n")
     (let ((sig-file (expand-file-name (mail-find-signature))))
       (if (file-exists-p sig-file)
    (insert-file-contents sig-file)
  (error "Signature file %s does not exist. Check mail-signature-alist."
         sig-file)))))

 (defun mail-find-signature ()
   "Find an appropriate signature file."
   (let* ((elist mail-signature-alist)
   (found nil)
   (sind 0)
   (entry (car elist))
   (header (car entry))
   (regex (car (cdr entry)))
   (file (car (cdr (cdr entry)))))
     (save-excursion
       (if (>= mail-signature-last-signature (length mail-signature-alist))
    (setq mail-signature-last-signature 0))
       (while (and (not found) elist)
  (if (and (mail-position-on-field header 'soft)
    (re-search-backward (concat header ":[ \t]*\\(.*\\)$")
          (point-min) t)
    (string-match regex (buffer-substring (match-beginning 1)
              (match-end 1))))
      (if (<= sind mail-signature-last-signature)
   (setq elist (cdr elist)
         entry (car elist)
         header (car entry)
         sind (1+ sind)
         regex (car (cdr entry))
         file (car (cdr (cdr entry))))
	(setq found t))
    (setq elist (cdr elist)
   entry (car elist)
   header (car entry)
   sind (1+ sind)
   regex (car (cdr entry))
   file (car (cdr (cdr entry)))))))
     (setq mail-signature-last-signature sind)
     (concat mail-signature-base file)))

 (provide 'mail-signature)

 ;;; mail-signature.el ends here

 #+END_SRC
*** ox-reveal.el                                                    :ARCHIVE:
 Creating presentations 

 #+BEGIN_SRC elisp :tangle lisp/ox-reveal.el
 ;;; ox-reveal.el --- reveal.js Presentation Back-End for Org Export Engine

 ;; Copyright (C) 2013 Yujie Wen

 ;; Author: Yujie Wen <yjwen.ty at gmail dot com>
 ;; Created: 2013-04-27
 ;; Version: 1.0
 ;; Package-Requires: ((org "8.0"))
 ;; Keywords: outlines, hypermedia, slideshow, presentation

 ;; This file is not part of GNU Emacs.

 ;;; Copyright Notice:

 ;; This program is free software: you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
 ;; the Free Software Foundation, either version 3 of the License, or
 ;; (at your option) any later version.

 ;; This program is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;; GNU General Public License for more details.

 ;; You should have received a copy of the GNU General Public License
 ;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

 ;; Please see "Readme.org" for detail introductions.

 ;; Pull request: Multiplex Support - Stephen Barrett <Stephen dot Barrewtt at scss dot tcd dot ie

 ;;; Code:

 (require 'ox-html)
 (require 'cl)

 (org-export-define-derived-backend 'reveal 'html

   :menu-entry
   '(?R "Export to reveal.js HTML Presentation"
	((?R "To file" org-reveal-export-to-html)
         (?B "To file and browse" org-reveal-export-to-html-and-browse)
         (?S "Current subtree to file" org-reveal-export-current-subtree)))

   :options-alist
   '((:reveal-control nil "reveal_control" org-reveal-control t)
     (:reveal-progress nil "reveal_progress" org-reveal-progress t)
     (:reveal-history nil  "reveal_history" org-reveal-history t)
     (:reveal-center nil "reveal_center" org-reveal-center t)
     (:reveal-rolling-links nil "reveal_rolling_links" org-reveal-rolling-links t)
     (:reveal-slide-number nil "reveal_slide_number" org-reveal-slide-number t)
     (:reveal-keyboard nil "reveal_keyboard" org-reveal-keyboard t)
     (:reveal-overview nil "reveal_overview" org-reveal-overview t)
     (:reveal-width nil "reveal_width" org-reveal-width t)
     (:reveal-height nil "reveal_height" org-reveal-height)
     (:reveal-margin "REVEAL_MARGIN" nil org-reveal-margin t)
     (:reveal-min-scale "REVEAL_MIN_SCALE" nil org-reveal-min-scale t)
     (:reveal-max-scale "REVEAL_MAX_SCALE" nil org-reveal-max-scale t)
     (:reveal-root "REVEAL_ROOT" nil org-reveal-root t)
     (:reveal-trans "REVEAL_TRANS" nil org-reveal-transition t)
     (:reveal-speed "REVEAL_SPEED" nil org-reveal-transition-speed t)
     (:reveal-theme "REVEAL_THEME" nil org-reveal-theme t)
     (:reveal-extra-css "REVEAL_EXTRA_CSS" nil org-reveal-extra-css nil)
     (:reveal-extra-js "REVEAL_EXTRA_JS" nil org-reveal-extra-js nil)
     (:reveal-hlevel "REVEAL_HLEVEL" nil nil t)
     (:reveal-title-slide nil "reveal_title_slide" org-reveal-title-slide t)
     (:reveal-title-slide-template "REVEAL_TITLE_SLIDE_TEMPLATE" nil org-reveal-title-slide-template space)
     (:reveal-title-slide-background "REVEAL_TITLE_SLIDE_BACKGROUND" nil nil t)
     (:reveal-title-slide-background-size "REVEAL_TITLE_SLIDE_BACKGROUND_SIZE" nil nil t)
     (:reveal-title-slide-background-repeat "REVEAL_TITLE_SLIDE_BACKGROUND_REPEAT" nil nil t)
     (:reveal-title-slide-background-transition "REVEAL_TITLE_SLIDE_BACKGROUND_TRANSITION" nil nil t)
     (:reveal-mathjax-url "REVEAL_MATHJAX_URL" nil org-reveal-mathjax-url t)
     (:reveal-preamble "REVEAL_PREAMBLE" nil org-reveal-preamble t)
     (:reveal-head-preamble "REVEAL_HEAD_PREAMBLE" nil org-reveal-head-preamble t)
     (:reveal-postamble "REVEAL_POSTAMBLE" nil org-reveal-postamble t)
     (:reveal-multiplex-id "REVEAL_MULTIPLEX_ID" nil org-reveal-multiplex-id nil)
     (:reveal-multiplex-secret "REVEAL_MULTIPLEX_SECRET" nil org-reveal-multiplex-secret nil)
     (:reveal-multiplex-url "REVEAL_MULTIPLEX_URL" nil org-reveal-multiplex-url nil)
     (:reveal-multiplex-socketio-url "REVEAL_MULTIPLEX_SOCKETIO_URL" nil org-reveal-multiplex-socketio-url nil)
     (:reveal-slide-header "REVEAL_SLIDE_HEADER" nil org-reveal-slide-header t)
     (:reveal-slide-footer "REVEAL_SLIDE_FOOTER" nil org-reveal-slide-footer t)
     (:reveal-plugins "REVEAL_PLUGINS" nil nil t)
     (:reveal-default-frag-style "REVEAL_DEFAULT_FRAG_STYLE" nil org-reveal-default-frag-style t)
     (:reveal-single-file nil "reveal_single_file" org-reveal-single-file t)
     (:reveal-init-script "REVEAL_INIT_SCRIPT" nil org-reveal-init-script space)
     (:reveal-highlight-css "REVEAL_HIGHLIGHT_CSS" nil org-reveal-highlight-css nil)
     )

   :translate-alist
   '((export-block . org-reveal-export-block)
     (headline . org-reveal-headline)
     (inner-template . org-reveal-inner-template)
     (item . org-reveal-item)
     (keyword . org-reveal-keyword)
     (link . org-reveal-link)
     (latex-environment . (lambda (latex-env contents info)
                            (setq info (plist-put info :reveal-mathjax t))
                            (org-html-latex-environment latex-env contents info)))
     (latex-fragment . (lambda (frag contents info)
                         (setq info (plist-put info :reveal-mathjax t))
                         (org-html-latex-fragment frag contents info)))
     (plain-list . org-reveal-plain-list)
     (quote-block . org-reveal-quote-block)
     (section . org-reveal-section)
     (src-block . org-reveal-src-block)
     (template . org-reveal-template))

   :filters-alist '((:filter-parse-tree . org-reveal-filter-parse-tree))
   :export-block '("REVEAL" "NOTES")
   )

 (defcustom org-reveal-root "./reveal.js"
   "The root directory of reveal.js packages. It is the directory
   within which js/reveal.js is."
   :group 'org-export-reveal)

 (defcustom org-reveal-hlevel 1
   "The minimum level of headings that should be grouped into
 vertical slides."
   :group 'org-export-reveal
   :type 'integer)

 (defun org-reveal--get-hlevel (info)
   "Get HLevel value safely.
 If option \"REVEAL_HLEVEL\" is set, retrieve integer value from it,
 else get value from custom variable `org-reveal-hlevel'."
   (let ((hlevel-str (plist-get info :reveal-hlevel)))
     (if hlevel-str (string-to-number hlevel-str)
       org-reveal-hlevel)))

 (defcustom org-reveal-title-slide t
   "Include a title slide."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-title-slide-template
   "<h1>%t</h1>
 <h2>%a</h2>
 <h2>%e</h2>
 <h2>%d</h2>"
   "Format template to specify title page slide. The format string
 can contain the following escaping elements:

   %s stands for the title.
   %a stands for the author's name.
   %e stands for the author's email.
   %d stands for the date.
   %% stands for a literal %.
 "
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-transition
   "default"
   "Reveal transistion style."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-transition-speed
   "default"
   "Reveal transistion speed."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-theme
   "moon"
   "Reveal theme."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-extra-js
   ""
   "URL to extra JS file."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-extra-css
   ""
   "URL to extra css file."
   :group 'org-export-reveal
   :type 'string)


 (defcustom org-reveal-multiplex-id ""
   "The ID to use for multiplexing."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-multiplex-secret ""
   "The secret to use for master slide."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-multiplex-url ""
   "The url of the socketio server."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-multiplex-socketio-url
   ""
   "the url of the socketio.js library"
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-control t
   "Reveal control applet."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-progress t
   "Reveal progress applet."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-history nil
   "Reveal history applet."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-center t
   "Reveal center applet."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-rolling-links nil
   "Reveal use rolling links."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-slide-number t
   "Reveal showing slide numbers."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-keyboard t
   "Reveal use keyboard navigation."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-overview t
   "Reveal show overview."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-width -1
   "Slide width"
   :group 'org-export-reveal
   :type 'integer)

 (defcustom org-reveal-height -1
   "Slide height"
   :group 'org-export-reveal
   :type 'integer)

 (defcustom org-reveal-margin "-1"
   "Slide margin"
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-min-scale "-1"
   "Minimum bound for scaling slide."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-max-scale "-1"
   "Maximum bound for scaling slide."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-mathjax nil
   "Obsolete. Org-reveal enable mathjax when it find latex
 content."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-mathjax-url
   "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
   "Default MathJax URL."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-preamble nil
   "Preamble contents."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-head-preamble nil
   "Preamble contents for head part."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-postamble nil
   "Postamble contents."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-slide-header nil
   "HTML content used as Reveal.js slide header"
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-slide-footer nil
   "HTML content used as Reveal.js slide footer"
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-default-frag-style nil
   "Default fragment style."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-plugins
   '(classList markdown zoom notes)
   "Default builtin plugins"
   :group 'org-export-reveal
   :type '(set
           (const classList)
           (const markdown)
           (const highlight)
           (const zoom)
           (const notes)
           (const search)
           (const remotes)
           (const multiplex)))

 (defcustom org-reveal-single-file nil
   "Export presentation into one single HTML file, which embedded
   JS scripts and pictures."
   :group 'org-export-reveal
   :type 'boolean)

 (defcustom org-reveal-init-script nil
   "Custom script that will be passed to Reveal.initialize."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-highlight-css "%r/lib/css/zenburn.css"
   "Hightlight.js CSS file."
   :group 'org-export-reveal
   :type 'string)

 (defcustom org-reveal-note-key-char "n"
   "If not nil, org-reveal-note-key-char's value is registered as
   the key character to Org-mode's structure completion for
   Reveal.js notes. When `<' followed by the key character are
   typed and then the completion key is pressed, which is usually
   `TAB', \"#+BEGIN_NOTES\" and \"#+END_NOTES\" is inserted.

   The default value is \"n\". Set the variable to nil to disable
   registering the completion"
   :group 'org-export-reveal
   :type 'string)

 (defun if-format (fmt val)
   (if val (format fmt val) ""))

 (defun frag-style (frag info)
   "Return proper fragment string according to FRAG and the default fragment style.
 FRAG is the fragment style set on element, INFO is a plist
 holding contextual information."
   (cond
    ((string= frag t)
     (let ((default-frag-style (plist-get info :reveal-default-frag-style)))
       (if default-frag-style (format "fragment %s" default-frag-style)
         "fragment")))
    (t (format "fragment %s" frag))))

 (defun frag-class (frag info)
   "Return proper HTML string description of fragment style.
 FRAG is the fragment style set on element, INFO is a plist
 holding contextual information."
   (and frag
	(format " class=\"%s\"" (frag-style frag info))))

 (defun org-reveal-export-block (export-block contents info)
   "Transocde a EXPORT-BLOCK element from Org to Reveal.
 CONTENTS is nil. INFO is a plist holding contextual information."
   (let ((block-type (org-element-property :type export-block))
         (block-string (org-element-property :value export-block)))
     (cond ((string= block-type "NOTES")
            (format "<aside class=\"notes\">\n%s\n</aside>\n"
                    (org-export-string-as block-string 'html 'body-only)))
           ((string= block-type "HTML")
            (org-remove-indentation block-string)))))

 ;; Copied from org-html-headline and modified to embed org-reveal
 ;; specific attributes.
 (defun org-reveal-headline (headline contents info)
   "Transcode a HEADLINE element from Org to HTML.
 CONTENTS holds the contents of the headline.  INFO is a plist
 holding contextual information."
   (unless (org-element-property :footnote-section-p headline)
     (if (org-export-low-level-p headline info)
         ;; This is a deep sub-tree: export it as in ox-html.
         (org-html-headline headline contents info)
       ;; Standard headline.  Export it as a slide
       (let* ((level (org-export-get-relative-level headline info))
	      (preferred-id (or (org-element-property :CUSTOM_ID headline)
				(org-export-get-reference headline info)
				(org-element-property :ID headline)))
	      (hlevel (org-reveal--get-hlevel info))
	      (header (plist-get info :reveal-slide-header))
	      (header-div (when header (format "<div class=\"slide-header\">%s</div>\n" header)))
	      (footer (plist-get info :reveal-slide-footer))
	      (footer-div (when footer (format "<div class=\"slide-footer\">%s</div>\n" footer)))
	      (first-sibling (org-export-first-sibling-p headline info))
	      (last-sibling (org-export-last-sibling-p headline info)))
         (concat
          (if (or (/= level 1) (not first-sibling))
              ;; Not the first heading. Close previou slide.
              (concat
               ;; Slide footer if any
               footer-div
               ;; Close previous slide
               "</section>\n"
               (if (<= level hlevel)
		   ;; Close previous vertical slide group.
		   "</section>\n")))
          (if (<= level hlevel)
              ;; Add an extra "<section>" to group following slides
              ;; into vertical slide group.
              "<section>\n")
          ;; Start a new slide.
          (format "<section %s%s>\n"
                  (org-html--make-attribute-string
                   `(:id ,(format "slide-%s" preferred-id)
                         :data-state ,(org-element-property :REVEAL_DATA_STATE headline)
                         :data-transition ,(org-element-property :REVEAL_DATA_TRANSITION headline)
                         :data-background ,(org-element-property :REVEAL_BACKGROUND headline)
                         :data-background-size ,(org-element-property :REVEAL_BACKGROUND_SIZE headline)
                         :data-background-repeat ,(org-element-property :REVEAL_BACKGROUND_REPEAT headline)
                         :data-background-transition ,(org-element-property :REVEAL_BACKGROUND_TRANS headline)))
                  (let ((extra-attrs (org-element-property :REVEAL_EXTRA_ATTR headline)))
                    (if extra-attrs (format " %s" extra-attrs) "")))
          ;; Slide header if any.
          header-div
          ;; The HTML content of the headline
          ;; Strip the <div> tags, if any
          (let ((html (org-html-headline headline contents info)))
            (if (string-prefix-p "<div" html)
		;; Remove the first <div> and the last </div> tags from html
		(concat "<"
			(mapconcat 'identity
                                   (butlast (cdr (split-string html "<" t)))
                                   "<"))
              ;; Return the HTML content unchanged
              html))
          (if (and (= level 1)
                   (org-export-last-sibling-p headline info))
              ;; Last head 1. Close all slides.
              (concat
               ;; Slide footer if any
               footer-div
               "</section>\n</section>\n")))))))

 (defgroup org-export-reveal nil
   "Options for exporting Orgmode files to reveal.js HTML pressentations."
   :tag "Org Export Reveal"
   :group 'org-export)

 (defun org-reveal--read-file (file)
   "Return the content of file"
   (with-temp-buffer
     (insert-file-contents-literally file)
     (buffer-string)))

 (defun org-reveal--file-url-to-path (url)
   "Convert URL that points to local files to file path."
   (replace-regexp-in-string
    (if (string-equal system-type "windows-nt") "^file:///" "^file://")
    "" url))

 (defun org-reveal-stylesheets (info)
   "Return the HTML contents for declaring reveal stylesheets
 using custom variable `org-reveal-root'."
   (let* ((root-path (file-name-as-directory (plist-get info :reveal-root)))
          (reveal-css (concat root-path "css/reveal.css"))
          (theme (plist-get info :reveal-theme))
          (theme-css (concat root-path "css/theme/" theme ".css"))
          ;; Local file names.
          (local-root (org-reveal--file-url-to-path root-path))
          (local-reveal-css (concat local-root "css/reveal.css"))
          (local-theme-css (concat local-root "css/theme/" theme ".css"))
          (in-single-file (plist-get info :reveal-single-file)))
     (concat
      ;; stylesheets
      (if (and in-single-file
               (file-readable-p local-reveal-css)
               (file-readable-p local-theme-css))
          ;; CSS files exist and are readable. Embed them.
          (concat "<style type=\"text/css\">\n"
                  (org-reveal--read-file local-reveal-css)
                  "\n"
                  (org-reveal--read-file local-theme-css)
                  "</style>\n")
	;; Fall-back to external CSS links.
	(if in-single-file
            ;; Tried to embed CSS files but failed. Print a message about possible errors.
            (error (concat "Cannot read "
                             (mapconcat 'identity
					(delq nil (mapcar (lambda (file) (if (not (file-readable-p file)) file))
                                                          (list local-reveal-css local-theme-css)))
					", "))))
	;; Create links to CSS files.
	(concat "<link rel=\"stylesheet\" href=\"" reveal-css "\"/>\n"
		"<link rel=\"stylesheet\" href=\"" theme-css "\" id=\"theme\"/>\n"))
      ;; extra css
      (let ((extra-css (plist-get info :reveal-extra-css)))
	(if (string= extra-css "") ""
          (format "<link rel=\"stylesheet\" href=\"%s\"/>\n" extra-css)))
      ;; Include CSS for highlight.js if necessary
      (if (org-reveal--using-highlight.js info)
          (format "<link rel=\"stylesheet\" href=\"%s\"/>" 
                  (format-spec (plist-get info :reveal-highlight-css)
                               `((?r . ,(directory-file-name root-path))))))
      ;; print-pdf
      (if in-single-file ""
	(format "
 <!-- If the query includes 'print-pdf', include the PDF print sheet -->
 <script>
     if( window.location.search.match( /print-pdf/gi ) ) {
         var link = document.createElement( 'link' );
         link.rel = 'stylesheet';
         link.type = 'text/css';
         link.href = '%scss/print/pdf.css';
         document.getElementsByTagName( 'head' )[0].appendChild( link );
     }
 </script>
 "
		root-path)))))

 (defun org-reveal-mathjax-scripts (info)
   "Return the HTML contents for declaring MathJax scripts"
   (if (plist-get info :reveal-mathjax)
       ;; MathJax enabled.
       (format "<script type=\"text/javascript\" src=\"%s\"></script>\n"
               (plist-get info :reveal-mathjax-url))))

 (defun org-reveal-scripts (info)
   "Return the necessary scripts for initializing reveal.js using
 custom variable `org-reveal-root'."
   (let* ((root-path (file-name-as-directory (plist-get info :reveal-root)))
          (head-min-js (concat root-path "lib/js/head.min.js"))
          (reveal-js (concat root-path "js/reveal.js"))
          ;; Local files
          (local-root-path (org-reveal--file-url-to-path root-path))
          (local-head-min-js (concat local-root-path "lib/js/head.min.js"))
          (local-reveal-js (concat local-root-path "js/reveal.js"))
          (in-single-file (plist-get info :reveal-single-file)))
     (concat
      ;; reveal.js/lib/js/head.min.js
      ;; reveal.js/js/reveal.js
      (if (and in-single-file
               (file-readable-p local-head-min-js)
               (file-readable-p local-reveal-js))
          ;; Embed scripts into HTML
          (concat "<script>\n"
                  (org-reveal--read-file local-head-min-js)
                  "\n"
                  (org-reveal--read-file local-reveal-js)
                  "\n</script>")
	;; Fall-back to extern script links
	(if in-single-file
            ;; Tried to embed scripts but failed. Print a message about possible errors.
            (error (concat "Cannot read "
                             (mapconcat 'identity
					(delq nil (mapcar (lambda (file) (if (not (file-readable-p file)) file))
                                                          (list local-head-min-js local-reveal-js)))
					", "))))
	(concat
         "<script src=\"" head-min-js "\"></script>\n"
         "<script src=\"" reveal-js "\"></script>\n"))
      ;; plugin headings
      "
 <script>
 // Full list of configuration options available here:
 // https://github.com/hakimel/reveal.js#configuration
 Reveal.initialize({
 "
      (format "
 controls: %s,
 progress: %s,
 history: %s,
 center: %s,
 slideNumber: %s,
 rollingLinks: %s,
 keyboard: %s,
 overview: %s,
 "
             (if (plist-get info :reveal-control) "true" "false")
             (if (plist-get info :reveal-progress) "true" "false")
             (if (plist-get info :reveal-history) "true" "false")
             (if (plist-get info :reveal-center) "true" "false")
             (if (plist-get info :reveal-slide-number) "true" "false")
             (if (plist-get info :reveal-rolling-links) "true" "false")
             (if (plist-get info :reveal-keyboard) "true" "false")
             (if (plist-get info :reveal-overview) "true" "false"))

      ;; slide width
      (let ((width (plist-get info :reveal-width)))
	(if (> width 0) (format "width: %d,\n" width) ""))

      ;; slide height
      (let ((height (plist-get info :reveal-height)))
	(if (> height 0) (format "height: %d,\n" height) ""))

      ;; slide margin
      (let ((margin (string-to-number (plist-get info :reveal-margin))))
	(if (>= margin 0) (format "margin: %.2f,\n" margin) ""))

      ;; slide minimum scaling factor
      (let ((min-scale (string-to-number (plist-get info :reveal-min-scale))))
	(if (> min-scale 0) (format "minScale: %.2f,\n" min-scale) ""))

      ;; slide maximux scaling factor
      (let ((max-scale (string-to-number (plist-get info :reveal-max-scale))))
	(if (> max-scale 0) (format "maxScale: %.2f,\n" max-scale) ""))

      ;; thems and transitions
      (format "
 theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
 transition: Reveal.getQueryHash().transition || '%s', // default/cube/page/concave/zoom/linear/fade/none
 transitionSpeed: '%s',\n"
              (plist-get info :reveal-trans)
              (plist-get info :reveal-speed))

      ;; multiplexing - depends on defvar 'client-multiplex'
      (when (plist-get info :reveal-multiplex-id)
	(format
 "multiplex: {
     secret: %s, // null if client
     id: '%s', // id, obtained from socket.io server
     url: '%s' // Location of socket.io server
 },\n"
              (if (eq client-multiplex nil)
                  (format "'%s'" (plist-get info :reveal-multiplex-secret))
		(format "null"))
              (plist-get info :reveal-multiplex-id)
              (plist-get info :reveal-multiplex-url)))

      ;; optional JS library heading
      (if in-single-file ""
	(concat
         "
 // Optional libraries used to extend on reveal.js
 dependencies: [
 "
         ;; JS libraries
         (let* ((builtins
                 '(classList (format " { src: '%slib/js/classList.js', condition: function() { return !document.body.classList; } }" root-path)
                   markdown (format " { src: '%splugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
  { src: '%splugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } }" root-path root-path)
                   highlight (format " { src: '%splugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }" root-path)
                   zoom (format " { src: '%splugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } }" root-path)
                   notes (format " { src: '%splugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }" root-path)
                   search (format " { src: '%splugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }" root-path)
                   remotes (format " { src: '%splugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }" root-path)
                   multiplex (format " { src: '%s', async: true },\n%s"
                                     (plist-get info :reveal-multiplex-socketio-url)
                                         ; following ensures that either client.js or master.js is included depending on defva client-multiplex value state
                                     (if (not client-multiplex)
                                         (progn
                                           (if (plist-get info :reveal-multiplex-secret)
                                               (setq client-multiplex t))
                                           (format " { src: '%splugin/multiplex/master.js', async: true }" root-path))
                                       (format " { src: '%splugin/multiplex/client.js', async: true }" root-path)))))
		(builtin-codes
                 (mapcar
                  (lambda (p)
                    (eval (plist-get builtins p)))
                  (let ((buffer-plugins (plist-get info :reveal-plugins)))
                    (cond
                     ((string= buffer-plugins "") ())
                     (buffer-plugins (car (read-from-string buffer-plugins)))
                     (t org-reveal-plugins)))))
		(extra-codes (plist-get info :reveal-extra-js))
		(total-codes
                 (if (string= "" extra-codes) builtin-codes
                   (append (list extra-codes) builtin-codes))))
           (mapconcat 'identity total-codes ",\n"))
         "]\n"
         (let ((init-script (plist-get info :reveal-init-script)))
           (if init-script (concat "," init-script)))
         ))
      "});\n</script>\n")))

 (defun org-reveal-toc (depth info)
   "Build a slide of table of contents."
   (let ((toc (org-html-toc depth info)))
     (if toc
         (format "<section id=\"table-of-contents\">\n%s</section>\n"
                 (replace-regexp-in-string "<a href=\"#" "<a href=\"#/slide-" toc)))))

 (defun org-reveal-inner-template (contents info)
   "Return body of document string after HTML conversion.
 CONTENTS is the transcoded contents string. INFO is a plist
 holding export options."
   (concat
    ;; Table of contents.
    (let ((depth (plist-get info :with-toc)))
      (when (and depth
                 (not (plist-get info :reveal-subtree)))
	(org-reveal-toc depth info)))
    ;; Document contents.
    contents))

 (defun org-reveal-parse-token (key &optional value)
   "Return HTML tags or perform SIDE EFFECT according to key"
   (case (intern key)
     (split "</section>\n<section>")))

 (defun org-reveal-parse-keyword-value (value)
   "According to the value content, return HTML tags to split slides."
   (let ((tokens (mapcar
                  (lambda (x) (split-string x ":"))
                  (split-string value))))
     (mapconcat
      (lambda (x) (apply 'org-reveal-parse-token x))
      tokens
      "")))

 ;; Copied from org-html-format-list-item. Overwrite HTML class
 ;; attribute when there is attr_html attributes.
 (defun org-reveal-format-list-item (contents type checkbox attributes info
					      &optional term-counter-id
					      headline)
   "Format a list item into HTML."
   (let ((attr-html (cond (attributes (format " %s" (org-html--make-attribute-string attributes)))
                          (checkbox (format " class=\"%s\"" (symbol-name checkbox)))
                          (t "")))
	 (checkbox (concat (org-html-checkbox checkbox info)
			   (and checkbox " ")))
	 (br (org-html-close-tag "br" nil info)))
     (concat
      (case type
	(ordered
	 (let* ((counter term-counter-id)
		(extra (if counter (format " value=\"%s\"" counter) "")))
	   (concat
	    (format "<li%s%s>" attr-html extra)
	    (when headline (concat headline br)))))
	(unordered
	 (let* ((id term-counter-id)
		(extra (if id (format " id=\"%s\"" id) "")))
	   (concat
	    (format "<li%s%s>" attr-html extra)
	    (when headline (concat headline br)))))
	(descriptive
	 (let* ((term term-counter-id))
	   (setq term (or term "(no term)"))
	   ;; Check-boxes in descriptive lists are associated to tag.
	   (concat (format "<dt%s>%s</dt>"
			   attr-html (concat checkbox term))
		   "<dd>"))))
      (unless (eq type 'descriptive) checkbox)
      (and contents (org-trim contents))
      (case type
	(ordered "</li>")
	(unordered "</li>")
	(descriptive "</dd>")))))

 ;; Copied from org-html-item, changed to call
 ;; org-reveal-format-list-item.
 (defun org-reveal-item (item contents info)
   "Transcode an ITEM element from Org to Reveal.
 CONTENTS holds the contents of the item.  INFO is a plist holding
 contextual information."
   (let* ((plain-list (org-export-get-parent item))
	  (type (org-element-property :type plain-list))
	  (counter (org-element-property :counter item))
          (attributes (org-export-read-attribute :attr_html item))
          ; (attributes (org-html--make-attribute-string (org-export-read-attribute :attr_html item)))
	  (checkbox (org-element-property :checkbox item))
	  (tag (let ((tag (org-element-property :tag item)))
		 (and tag (org-export-data tag info)))))
     (org-reveal-format-list-item
      contents type checkbox attributes info (or tag counter))))

 (defun org-reveal-keyword (keyword contents info)
   "Transcode a KEYWORD element from Org to Reveal,
 and may change custom variables as SIDE EFFECT.
 CONTENTS is nil. INFO is a plist holding contextual information."
   (let ((key (org-element-property :key keyword))
         (value (org-element-property :value keyword)))
     (case (intern key)
       (REVEAL (org-reveal-parse-keyword-value value))
       (REVEAL_HTML value))))
 (defun org-reveal-embedded-svg (path)
   "Embed the SVG content into Reveal HTML."
   (with-temp-buffer
     (insert-file-contents-literally path)
     (let ((start (re-search-forward "<[ \t\n]*svg[ \t\n]"))
           (end (re-search-forward "<[ \t\n]*/svg[ \t\n]*>")))
       (concat "<svg " (buffer-substring-no-properties start end)))))

 (defun org-reveal--format-image-data-uri (link path info)
   "Generate the data URI for the image referenced by LINK."
   (let* ((ext (downcase (file-name-extension path))))
     (message "link=%s" link)
     (if (string= ext "svg")
         (org-reveal-embedded-svg path)
       (org-html-close-tag
	"img"
	(org-html--make-attribute-string
         (org-combine-plists
          (list :src
		(concat
                 "data:image/"
                 ;; Image type
                 ext
                 ";base64,"
                 ;; Base64 content
                 (with-temp-buffer
                   (insert-file-contents-literally path)
                   (base64-encode-region 1 (point-max))
                   (buffer-string))))
          ;; Get attribute list from parent element
          ;; Copied from ox-html.el
          (let* ((parent (org-export-get-parent-element link))
                 (link (let ((container (org-export-get-parent link)))
                         (if (and (eq (org-element-type container) 'link)
                                  (org-html-inline-image-p link info))
                             container
                           link))))
            (and (eq (org-element-map parent 'link 'identity info t) link)
                 (org-export-read-attribute :attr_html parent)))))
	info))))

 (defun org-reveal-link (link desc info)
   "Transcode a LINK object from Org to Reveal. The result is
   identical to ox-html expect for image links. When `org-reveal-single-file' is t,
 the result is the Data URIs of the referenced image."
   (let* ((want-embed-image (and (plist-get info :reveal-single-file)
                                 (plist-get info :html-inline-images)
                                 (org-export-inline-image-p
                                  link (plist-get info :html-inline-image-rules))))
          (raw-path (org-element-property :path link))
          (clean-path (org-reveal--file-url-to-path raw-path))
          (can-embed-image (and want-embed-image
				(file-readable-p clean-path))))
     (if can-embed-image
         (org-reveal--format-image-data-uri link clean-path info)
       (if want-embed-image
           (error "Cannot embed image %s" raw-path)
         (replace-regexp-in-string "<a href=\"#" "<a href=\"#/slide-"
                                   (org-html-link link desc info))))))

 (defun org-reveal-plain-list (plain-list contents info)
   "Transcode a PLAIN-LIST element from Org to Reveal.

 CONTENTS is the contents of the list. INFO is a plist holding
 contextual information.

 Extract and set `attr_html' to plain-list tag attributes."
   (let ((tag (case (org-element-property :type plain-list)
		(ordered "ol")
		(unordered "ul")
		(descriptive "dl")))
         (attrs (org-export-read-attribute :attr_html plain-list)))
     (format "<%s%s>\n%s\n</%s>\n"
             tag
             (if attrs (concat " " (org-html--make-attribute-string attrs)) "")
             contents
             tag)))

 (defun org-reveal--build-pre/postamble (type info)
   "Return document preamble or postamble as a string, or nil."
   (let ((section (plist-get info (intern (format ":reveal-%s" type))))
         (spec (org-html-format-spec info)))
     (when section
       (let ((section-contents
              (if (functionp (intern section)) (funcall (intern section) info)
		;; else section is a string.
		(format-spec section spec))))
         (when (org-string-nw-p section-contents)
            (org-element-normalize-string section-contents))))))


 (defun org-reveal-section (section contents info)
   "Transcode a SECTION element from Org to Reveal.
 CONTENTS holds the contents of the section. INFO is a plist
 holding contextual information."
   ;; Just return the contents. No "<div>" tags.
   contents)

 (defun org-reveal--using-highlight.js (info)
   "Check whether highlight.js plugin is enabled."
   (memq 'highlight (or (car (read-from-string (plist-get info :reveal-plugins)))
			org-reveal-plugins)))

 (defun org-reveal-src-block (src-block contents info)
   "Transcode a SRC-BLOCK element from Org to Reveal.
 CONTENTS holds the contents of the item.  INFO is a plist holding
 contextual information."
   (if (org-export-read-attribute :attr_html src-block :textarea)
       (org-html--textarea-block src-block)
     (let* ((use-highlight (org-reveal--using-highlight.js info))
            (lang (org-element-property :language src-block))
            (caption (org-export-get-caption src-block))
            (code (if (not use-highlight)
                      (org-html-format-code src-block info)
                    (cl-letf (((symbol-function 'org-html-htmlize-region-for-paste)
                               #'buffer-substring))
                      (org-html-format-code src-block info))))
            (frag (org-export-read-attribute :attr_reveal src-block :frag))
            (label (let ((lbl (org-element-property :name src-block)))
                     (if (not lbl) ""
                       (format " id=\"%s\"" lbl)))))
       (if (not lang)
           (format "<pre %s%s>\n%s</pre>"
                   (or (frag-class frag info) " class=\"example\"")
                   label
                   code)
         (format
          "<div class=\"org-src-container\">\n%s%s\n</div>"
          (if (not caption) ""
            (format "<label class=\"org-src-name\">%s</label>"
                    (org-export-data caption info)))
          (if use-highlight
              (format "\n<pre%s%s><code class=\"%s\">%s</code></pre>"
                      (or (frag-class frag info) "")
                      label lang code)
            (format "\n<pre %s%s>%s</pre>"
                    (or (frag-class frag info)
			(format " class=\"src src-%s\"" lang))
                    label code)))))))

 (defun org-reveal-quote-block (quote-block contents info)
   "Transcode a QUOTE-BLOCK element from Org to Reveal.
 CONTENTS holds the contents of the block INFO is a plist holding
 contextual information."
   (format "<blockquote %s>\n%s</blockquote>"
           (frag-class (org-export-read-attribute :attr_reveal quote-block :frag) info)
           contents))


 (defun org-reveal-template (contents info)
   "Return complete document string after HTML conversion.
 contents is the transcoded contents string.
 info is a plist holding export options."
   (concat
    (format "<!DOCTYPE html>\n<html%s>\n<head>\n"
            (if-format " lang=\"%s\"" (plist-get info :language)))
    "<meta charset=\"utf-8\"/>\n"
    (if-format "<title>%s</title>\n" (org-export-data (plist-get info :title) info))
    (if-format "<meta name=\"author\" content=\"%s\"/>\n" (plist-get info :author))
    (if-format "<meta name=\"description\" content=\"%s\"/>\n" (plist-get info :description))
    (if-format "<meta name=\"keywords\" content=\"%s\"/>\n" (plist-get info :keywords))
    (org-reveal-stylesheets info)
    (org-reveal-mathjax-scripts info)
    (org-reveal--build-pre/postamble 'head-preamble info)
    "</head>
 <body>\n"
    (org-reveal--build-pre/postamble 'preamble info)
    "<div class=\"reveal\">
 <div class=\"slides\">\n"
    (if (and (plist-get info :reveal-title-slide)
             (not (plist-get info :reveal-subtree)))
	(concat
         (format "<section id=\"sec-title-slide\"%s%s%s%s>\n"
                 (if-format " data-background=\"%s\""
                            (plist-get info :reveal-title-slide-background))
                 (if-format " data-background-size=\"%s\""
                            (plist-get info :reveal-title-slide-background-size))
                 (if-format " data-background-repeat=\"%s\""
                            (plist-get info :reveal-title-slide-background-repeat))
                 (if-format " data-background-transition=\"%s\""
                            (plist-get info :reveal-title-slide-background-transition)))
         (format-spec (plist-get info :reveal-title-slide-template) (org-html-format-spec info))
         "\n</section>\n")
      "")
    contents
    "</div>
 </div>\n"
    (org-reveal--build-pre/postamble 'postamble info)
    (org-reveal-scripts info)
    "</body>
 </html>\n"))

 (defun org-reveal-filter-parse-tree (tree backend info)
   "Do filtering before parsing TREE.

 Tree is the parse tree being exported. BACKEND is the export
 back-end used. INFO  is a plist-used as a communication channel.

 Assuming BACKEND is `reveal'.

 Each `attr_reveal' attribute is mapped to corresponding
 `attr_html' attributes."
   (let ((default-frag-style (plist-get info :reveal-default-frag-style)))
     (org-element-map tree (remq 'item org-element-all-elements)
       (lambda (elem) (org-reveal-append-frag elem default-frag-style))))
   ;; Return the updated tree.
   tree)

 (defun org-reveal--update-attr-html (elem frag &optional frag-index)
   "Update ELEM's attr_html atrribute with reveal's
 fragment attributes."
   (let ((attr-html (org-element-property :attr_html elem)))
     (when (and frag (not (string= frag "none")))
       (push (cond ((string= frag t) ":class fragment")
                   (t (format ":class fragment %s" frag)))
             attr-html)
       (when frag-index
         (push (format ":data-fragment-index %s" frag-index) attr-html)))
     (org-element-put-property elem :attr_html attr-html)))

 (defun org-reveal-append-frag (elem default-style)
   "Read org-reveal's fragment attribute from ELEM and append
 transformed fragment attribute to ELEM's attr_html plist."
   (let ((frag (org-export-read-attribute :attr_reveal elem :frag))
         (frag-index (org-export-read-attribute :attr_reveal elem :frag_idx)))
     (if frag
         (cond ((and (string= (org-element-type elem) 'plain-list)
                     (char-equal (string-to-char frag) ?\())
		(let* ((frag-list (car (read-from-string frag)))
                       (frag-list (if default-style
                                      (mapcar (lambda (s)
						"Replace t with default-style"
						(if (string= s t) default-style
                                                  s))
                                              frag-list)
                                    frag-list))
                       (items (org-element-contents elem)))
                  (if frag-index
                      (mapcar* 'org-reveal--update-attr-html
                               items frag-list (car (read-from-string frag-index)))
                    ;; Make frag-list tail circular
                    (nconc frag-list (last frag-list))
                    (mapcar* 'org-reveal--update-attr-html items frag-list))))
               (t (org-reveal--update-attr-html elem frag frag-index))))
     elem))

 (defvar client-multiplex nil
   "used to cause generation of client html file for multiplex")

 (defun org-reveal-export-to-html
   (&optional async subtreep visible-only body-only ext-plist)
   "Export current buffer to a reveal.js HTML file."
   (interactive)
   (let* ((extension (concat "." org-html-extension))
          (file (org-export-output-file-name extension subtreep))
          (clientfile (org-export-output-file-name (concat "_client" extension) subtreep)))

     ; export filename_client HTML file if multiplexing
     (setq client-multiplex nil)
     (setq retfile (org-export-to-file 'reveal file
                     async subtreep visible-only body-only ext-plist))

     ; export the client HTML file if client-multiplex is set true
     ; by previous call to org-export-to-file
     (if (eq client-multiplex t)
         (org-export-to-file 'reveal clientfile
           async subtreep visible-only body-only ext-plist))
     (cond (t retfile))))

 (defun org-reveal-export-to-html-and-browse
   (&optional async subtreep visible-only body-only ext-plist)
   "Export current buffer to a reveal.js and browse HTML file."
   (interactive)
   (browse-url-of-file (expand-file-name (org-reveal-export-to-html async subtreep visible-only body-only ext-plist))))

 (defun org-reveal-export-current-subtree
     (&optional async subtreep visible-only body-only ext-plist)
   "Export current subtree to a Reveal.js HTML file."
   (interactive)
   (org-narrow-to-subtree)
   (let ((ret (org-reveal-export-to-html async subtreep visible-only body-only (plist-put ext-plist :reveal-subtree t))))
     (widen)
     ret))

 ;;;###autoload
 (defun org-reveal-publish-to-reveal
  (plist filename pub-dir)
   "Publish an org file to Html.

 FILENAME is the filename of the Org file to be published.  PLIST
 is the property list for the given project.  PUB-DIR is the
 publishing directory.

 Return output file name."
   (org-publish-org-to 'reveal filename ".html" plist pub-dir))

 ;; Register auto-completion for speaker notes.
 (when org-reveal-note-key-char
   (add-to-list 'org-structure-template-alist
		(list org-reveal-note-key-char "#+BEGIN_NOTES\n\?\n#+END_NOTES")))

 (provide 'ox-reveal)

 ;;; ox-reveal.el ends here

 #+END_SRC
*** HOLD [[https://github.com/oliyh/re-jump.el][re-jump.el]] re-frame clojure jumping
 I should use this. 

 #+BEGIN_SRC elisp :tangle lisp/re-jump.el
 ;;; re-jump.el --- emacs navigation for re-frame projects

 ;; Copyright © 2017 Oliver Hine
 ;;
 ;; Author: Oliver Hine

 ;; This program is free software: you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
 ;; the Free Software Foundation, either version 3 of the License, or
 ;; (at your option) any later version.

 ;; This program is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;; GNU General Public License for more details.

 ;; You should have received a copy of the GNU General Public License
 ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

 ;; This file is not part of GNU Emacs.

 ;;; Commentary:

 ;; Jump to registrations of re-frame subscriptions, event handlers and fx

 ;;; Code:
 (require 'cider-util)
 (require 'cider-resolve)
 (require 'cider-client)
 (require 'cider-common)
 (require 'cider-interaction)
 (require 'clojure-mode)

 (defun re-frame-jump-to-reg ()
   (interactive)
   (let* ((kw (cider-symbol-at-point 'look-back))
          (ns-qualifier (and
                         (string-match "^:+\\(.+\\)/.+$" kw)
                         (match-string 1 kw)))
          (kw-ns (if ns-qualifier
                     (cider-resolve-alias (cider-current-ns) ns-qualifier)
                   (cider-current-ns)))
          (kw-to-find (concat "::" (replace-regexp-in-string "^:+\\(.+/\\)?" "" kw))))

     (when (and ns-qualifier (string= kw-ns (cider-current-ns)))
       (error "Could not resolve alias \"%s\" in %s" ns-qualifier (cider-current-ns)))

     (progn (cider-find-ns "-" kw-ns)
            (search-forward-regexp (concat "reg-[a-zA-Z-]*[ \\\n]+" kw-to-find) nil 'noerror))))

 (global-set-key (kbd "M->") 're-frame-jump-to-reg)

 (provide 're-jump)
 ;;; re-jump.el ends here

 #+END_SRC
*** soar.el                                                         :ARCHIVE:
 My forays into making a mode for soar. Incomplete. 

 #+BEGIN_SRC elisp :tangle lisp/soar.el
 ;(require 'smie) ; Alternative indentation
 (require 'hi-lock)
 (defvar soar-mode-hook nil)
 (defvar soar-mode-map
   (let ((map (make-keymap)))
     (define-key map "\C-j" 'newline-and-indent)
     map)
   "Keymap for Soar major mode")
 ;;;###autoload
 (add-to-list 'auto-mode-alist '("\\.soar\\'" . soar-mode))

 ;;; Keywords
 (defconst soar-font-lock-keywords
   (list
    '("\\<\\(sp .*\\)\\|}\\>" . font-lock-function-name-face)
    '("\\<\\(cmd\\|exec\\|print\\|\\(?:sta\\|wri\\)te\\)\\>" . font-lock-keyword-face)
    '("\\(-->\\)" . 'hi-red-b)
    '("\\(\\^[^ ]*\\)" . font-lock-string-face)
    '("\\(#.*\\)" . font-lock-comment-face)
    '("\\(<[a-zA-Z0-9_-]*>\\)" . font-lock-variable-name-face)) ; variables of form <sobj>
					 ; also need variables of form ^edge1
   "Default highlighting expressions for Soar mode")

 (defun soar-indent-line ()
   (save-excursion
     (beginning-of-line)
     (indent-line-to (* 2 (car (syntax-ppss))))))

 ;; Syntax Table	 (comment display)
 (defvar soar-mode-syntax-table
   (let ((st (make-syntax-table)))
 ;;    (modify-syntax-entry ?* "w" st)
     (modify-syntax-entry ?# "< b" st)
     (modify-syntax-entry ?\n "> b" st)
     st)
   "Syntax table for soar-mode")

 ;;;; define the major mode.
 (define-derived-mode soar-mode perl-mode;;fundamental-mode ;; perl-mode
   "Soar-mode is a major mode for editing the Soar AI language."
   :syntax-table soar-mode-syntax-table
  
   (setq font-lock-defaults '(soar-font-lock-keywords))
   (setq mode-name "SOAR")
   ;; modify the keymap
   ;(define-key soar-mode-map [remap comment-dwim] 'soar-comment-dwim)

   ;; indentation
   (set (make-local-variable 'indent-line-function) 'soar-indent-line)  
   ;;(smie-setup nil #'ignore)
 )

 (provide 'soar-mode)

 #+END_SRC
*** [[https://github.com/emacsmirror/emacswiki.org/blob/master/thingatpt+.el][thingatpt+.el]]                                                   :ARCHIVE:
 Drew Adams, providing thing-at-pt functionality I don't even know what to do with yet. 

 #+BEGIN_SRC elisp :tangle lisp/thingatpt+.el
 ;;; thingatpt+.el --- Extensions to `thingatpt.el'.
 ;;
 ;; Filename: thingatpt+.el
 ;; Description: Extensions to `thingatpt.el'.
 ;; Author: Drew Adams
 ;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
 ;; Copyright (C) 1996-2018, Drew Adams, all rights reserved.
 ;; Created: Tue Feb 13 16:47:45 1996
 ;; Version: 0
 ;; Last-Updated: Mon Jan  1 16:05:56 2018 (-0800)
 ;;           By: dradams
 ;;     Update #: 2334
 ;; URL: https://www.emacswiki.org/emacs/download/thingatpt%2b.el
 ;; Doc URL: https://www.emacswiki.org/emacs/ThingAtPointPlus#ThingAtPoint%2b
 ;; Keywords: extensions, matching, mouse
 ;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
 ;;
 ;; Features that might be required by this library:
 ;;
 ;;   `thingatpt'.
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;;; Commentary:
 ;;
 ;;    Extensions to `thingatpt.el'.
 ;;
 ;;
 ;;  Commands defined here:
 ;;
 ;;    `find-fn-or-var-nearest-point', `forward-char-same-line',
 ;;    `forward-whitespace-&-newlines', `tap-put-thing-at-point-props',
 ;;    `tap-redefine-std-fns'.
 ;;
 ;;  User options defined here:
 ;;
 ;;    `tap-near-point-x-distance', `tap-near-point-y-distance'.
 ;;
 ;;  Non-interactive functions defined here:
 ;;
 ;;    `tap-bounds-of-color-at-point', `tap-bounds-of-form-at-point',
 ;;    `tap-bounds-of-form-nearest-point',
 ;;    `tap-bounds-of-list-at-point',
 ;;    `tap-bounds-of-list-contents-at-point',
 ;;    `tap-bounds-of-list-nearest-point',
 ;;    `tap-bounds-of-number-at-point',
 ;;    `tap-bounds-of-number-at-point-decimal',
 ;;    `tap-bounds-of-number-at-point-hex',
 ;;    `tap-bounds-of-sexp-at-point',
 ;;    `tap-bounds-of-sexp-nearest-point',
 ;;    `tap-bounds-of-string-at-point',
 ;;    `tap-bounds-of-string-contents-at-point',
 ;;    `tap-bounds-of-symbol-at-point',
 ;;    `tap-bounds-of-symbol-nearest-point',
 ;;    `tap-bounds-of-thing-nearest-point', `tap-color-at-point',
 ;;    `tap-color-nearest-point',
 ;;    `tap-color-nearest-point-with-bounds',
 ;;    `tap-define-aliases-wo-prefix', `tap-form-at-point-with-bounds',
 ;;    `tap-form-nearest-point', `tap-form-nearest-point-with-bounds',
 ;;    `tap-list-at/nearest-point-with-bounds',
 ;;    `tap-list-at-point-with-bounds', `tap-list-contents-at-point',
 ;;    `tap-list-contents-nearest-point', `tap-list-nearest-point',
 ;;    `tap-list-nearest-point-with-bounds',
 ;;    `tap-list-nearest-point-as-string', `tap-looking-at-p',
 ;;    `tap-looking-back-p', `tap-non-nil-symbol-name-at-point',
 ;;    `tap-non-nil-symbol-name-nearest-point',
 ;;    `tap-non-nil-symbol-nearest-point',
 ;;    `tap-number-at-point-decimal', `tap-number-at-point-hex',
 ;;    `tap-number-nearest-point', `tap-read-from-whole-string',
 ;;    `tap-region-or-word-at-point',
 ;;    `tap-region-or-word-nearest-point',
 ;;    `tap-region-or-non-nil-symbol-name-nearest-point',
 ;;    `tap-sentence-nearest-point', `tap-sexp-at-point-with-bounds',
 ;;    `tap-sexp-nearest-point', `tap-sexp-nearest-point-with-bounds',
 ;;    `tap-string-at-point', `tap-string-contents-at-point',
 ;;    `tap-string-contents-nearest-point', `tap-string-match-p',
 ;;    `tap-string-nearest-point', `tap-symbol-at-point-with-bounds',
 ;;    `tap-symbol-name-at-point', `tap-symbol-name-nearest-point',
 ;;    `tap-symbol-nearest-point',
 ;;    `tap-symbol-nearest-point-with-bounds', `tap-thing-at-point',
 ;;    `tap-thing-at-point-as-string',
 ;;    `tap-thing-at-point-with-bounds',
 ;;    `tap-thing/form-nearest-point-with-bounds',
 ;;    `tap-thing-nearest-point',
 ;;    `tap-thing-nearest-point-with-bounds',
 ;;    `tap-unquoted-list-at-point', `tap-unquoted-list-nearest-point',
 ;;    `tap-unquoted-list-nearest-point-as-string',
 ;;    `tap-word-nearest-point',
 ;;
 ;;    plus the same functions without the prefix `tap-', if you invoke
 ;;    `tap-redefine-std-fns'.
 ;;
 ;;
 ;;  A REMINDER (the doc strings are not so great):
 ;;
 ;;    These functions, defined in `thingatpt.el', all move point:
 ;;      `beginning-of-thing', `end-of-sexp', `end-of-thing',
 ;;      `forward-symbol', `forward-thing'.
 ;;
 ;;  For older Emacs releases that do not have the following functions,
 ;;  they are defined here as no-ops:
 ;;
 ;;  `constrain-to-field', `field-beginning', `field-end'.
 ;;
 ;;
 ;;  How To Use This Library
 ;;  =======================
 ;;
 ;;  End Users
 ;;  ---------
 ;;
 ;;  Load this library after loading the standard GNU file
 ;;  `thingatpt.el'.  You can put this in your init file (`~/.emacs'):
 ;;
 ;;    (eval-after-load "thingatpt" '(require 'thingatpt+))
 ;;
 ;;  That defines new functions and improved versions of some of the
 ;;  standard thing-at-point functions.  All such functions have the
 ;;  prefix `tap-', so they are not used by default in any way.
 ;;
 ;;  Requiring library `thingatpt+.el' does not, however, make Emacs
 ;;  use the improved functions.  Merely loading it does not change the
 ;;  behavior of thing-at-point features.
 ;;
 ;;  If you want functions defined here to be used for calls to
 ;;  standard Emacs functions that make use of the `thing-at-point' and
 ;;  `bounds-of-thing-at-point' symbol properties for standard thing
 ;;  types (e.g. `list'), then put this in your init file, instead:
 ;;
 ;;    (eval-after-load "thingatpt"
 ;;      '(when (require 'thingatpt+)
 ;;         (tap-put-thing-at-point-props))
 ;;
 ;;  Note that some of my other libraries, including Icicles,
 ;;  Bookmark+, `grep+.el', `replace+.el', and `strings.el', do exactly
 ;;  that.  Note too that `tap-put-thing-at-point-props' improves the
 ;;  behavior of (thing-at-point 'list) - see below.
 ;;
 ;;  A further step, which I recommend, is to use the `tap-' versions
 ;;  of standard functions, defined here, everywhere in place of those
 ;;  standard functions.  In other words, redefine the standard
 ;;  functions as the `tap-' versions defined here.  For example,
 ;;  redefine `bounds-of-thing-at-point' to do what
 ;;  `tap-bounds-of-thing-at-point' does.
 ;;
 ;;  (If you do that then you need not invoke
 ;;  `tap-put-thing-at-point-props' to pick up the versions defined
 ;;  here of standard functions.  The property values set by vanilla
 ;;  library `thingatpt.el' will be OK because the functions themselves
 ;;  will have been redefined in that case.)
 ;;
 ;;  To get the most out of this library, I recommend that you put
 ;;  (only) the following in your init file:
 ;;
 ;;    (eval-after-load "thingatpt"
 ;;      '(when (require 'thingatpt+)
 ;;         (tap-redefine-std-fns))
 ;;
 ;;  That makes all Emacs code that uses the following standard
 ;;  functions use the their versions that are defined here, not the
 ;;  vanilla versions defined in `thingatpt.el'.
 ;;
 ;;  `bounds-of-thing-at-point' - Better behavior.
 ;;                               Accept optional arg SYNTAX-TABLE.
 ;;  `form-at-point'            - Accept optional arg SYNTAX-TABLE.
 ;;  `list-at-point'            - Better behavior.
 ;;  `symbol-at-point'          - Use `emacs-lisp-mode-syntax-table'.
 ;;  `thing-at-point'           - Ensure it returns a string or nil.
 ;;                               Accept optional arg SYNTAX-TABLE.
 ;;  `thing-at-point-bounds-of-list-at-point'
 ;;                             - Better behavior.  Accept optional
 ;;                               args UP and UNQUOTEDP.
 ;;
 ;;
 ;;  Lisp Programmers
 ;;  ----------------
 ;;
 ;;  If you write code that uses some of the functions defined here,
 ;;  this section is for you.
 ;;
 ;;  You can use the functions defined in `thingatpt+.el' that have
 ;;  prefix `tap-' to obtain, for your code, the improvements they
 ;;  provide.  Doing only that has no effect on any code that calls
 ;;  vanilla thing-at-point functions (which have no prefix `tap-').
 ;;
 ;;  For convenience you can invoke `tap-define-aliases-wo-prefix' to
 ;;  provide alias functions that have the same names but without the
 ;;  prefix `tap-'.  This affects only functions defined here that have
 ;;  no vanilla counterpart, so the aliases do not collide with any
 ;;  standard Emacs functions.  This is just a naming convenience.
 ;;
 ;;  For example, you might do this:
 ;;
 ;;    (when (require 'thingatpt+ nil t)  ; (no error if not found)
 ;;      (tap-define-aliases-wo-prefix))
 ;;
 ;;  You can optionally enable the improvements defined here to have
 ;;  wider application, so that code that does not directly invoke the
 ;;  functions defined here nevertheless uses them indirectly.
 ;;
 ;;  You can, for example, put `tap-' functions on THING-type symbols
 ;;  as property `thing-at-point' or property
 ;;  `bounds-of-thing-at-point'.  That has the effect of using those
 ;;  `tap-' functions for those THING types only.
 ;;
 ;;  For example, to get the improvements for lists offered by
 ;;  `tap-list-at-point', you can do this:
 ;;
 ;;    (put 'list 'bounds-of-thing-at-point
 ;;         'tap-bounds-of-list-at-point)
 ;;    (put 'list 'thing-at-point 'tap-list-at-point)
 ;;
 ;;  That causes the vanilla thing-at-point functions to invoke those
 ;;  `tap-' functions when handling lists.  It has an effect only on
 ;;  lists, not on other THINGs.  This behavior happens because the
 ;;  generic vanilla functions `thing-at-point' and
 ;;  `bounds-of-thing-at-point' use those standard symbol properties.
 ;;
 ;;  For even wider application, that is, if you want all of the
 ;;  improvements defined here to be available generally, then you will
 ;;  also need to do ONE of the following (#1 or #2):
 ;;
 ;;  1. Call `tap-redefine-std-fns', to redefine standard functions.
 ;;
 ;;  2. Do BOTH of these things:
 ;;
 ;;    a. Call `tap-put-thing-at-point-props', to substitute `tap-'
 ;;       functions for standard functions as the values of symbol
 ;;       properties `thing-at-point' and `bounds-of-thing-at-point'.
 ;;
 ;;    b. Call the individual `tap-*' functions explicitly for each of
 ;;       the standard functions that would be redefined by
 ;;       `tap-redefine-std-fns'.  Or call standard functions that make
 ;;       use of property `thing-at-point' or
 ;;       `bounds-of-thing-at-point'.
 ;;
 ;;    This (#2) changes (improves) the behavior of things like
 ;;    (thing-at-point 'list), even though it does not redefine any
 ;;    standard functions.  Again, this is because functions
 ;;    `thing-at-point' and `bounds-of-thing-at-point' use symbol
 ;;    properties `thing-at-point' and `bounds-of-thing-at-point', and
 ;;    `tap-put-thing-at-point-props' changes those property values.
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;;; Change Log:
 ;;
 ;; 2016/11/21 dadams
 ;;     Rename tap-thing-at-point to tap-thing-at-point-as-string and add new def of former.
 ;;     The new def follows vanilla Emacs in letting property thing-at-point return non-string.
 ;;     tap-form-at-point: Use tap-thing-at-point-as-string.
 ;;     tap-region-or-word-at-point: Use args STRICT REALLY-WORD with current-word.
 ;; 2016/11/04 dadams
 ;;     tap-thing-at-point: Added optional arg NO-PROPERTIES, per Emacs 24.4+.
 ;;     tap-form-at-point, tap-non-nil-symbol-name-at-point:
 ;;       Use nil for optional arg NO-PROPERTIES in call to tap-thing-at-point.
 ;; 2016/09/06 dadams
 ;;     Added: tap-read-from-whole-string.
 ;;     tap-form-at-point(-with-bounds): Use tap-read-from-whole-string.
 ;; 2016/08/30 dadams
 ;;     tap-string-match-p: Do NOT alias string-match-p, because that is a defsubst.
 ;; 2016/06/20 dadams
 ;;     tap-thing-at-point:
 ;;       Typo: convert result of funcall, not original THING, to string.  Thx to Tino Calancha.
 ;; 2015/08/23 dadams
 ;;     tap-list-at/nearest-point-with-bounds:
 ;;       Use (nth 3 (syntax-ppss)) for Emacs 25+ - see Emacs bug #20732.
 ;; 2014/08/22 dadams
 ;;     tap-looking-at-p: Do not defalias to Emacs looking-at-p because that is a defsubst.
 ;; 2014/06/07 dadams
 ;;     Added: tap-bounds-of-list-contents-at-point, tap-list-contents-at-point,
 ;;            tap-list-contents-nearest-point.
 ;;     Put tap-bounds-of-(string|list)-contents-at-point as bounds-of-thing-at-point property.
 ;; 2013/09/20 dadams
 ;;     Added: tap-bounds-of-string-contents-at-point, tap-string-contents-at-point,
 ;;            tap-string-contents-nearest-point.
 ;;     tap-define-aliases-wo-prefix: Updated for new functions.
 ;;     tap-bounds-of-string-at-point (incompatible change):
 ;;       Include " chars in string returned.  Return the string also when point on ending ".
 ;; 2013/09/13 dadams
 ;;     tap-thing/form-nearest-point-with-bounds:
 ;;       Do not skip looping over chars in same line when eobp.
 ;; 2012/11/10 dadams
 ;;     Added: tap(-bounds-of)-color-at-point, tap-color-nearest-point(-with-bounds).
 ;;     tap-word-nearest-point: Corrected doc string: returns nil if none found.
 ;; 2012/08/24 dadams
 ;;     Added: tap-string-match-p, tap-looking-at-p, tap-looking-back-p.
 ;;     tap-list-at/nearest-point-with-bounds: Handle point inside a string.
 ;;     tap-number-at-point-(hex|decimal): Use tap-string-match-p.
 ;; 2012/08/22 dadams
 ;;     Added: tap-bounds-of-number-at-point(-decimal|-hex).
 ;;     tap-thing-at-point, tap-bounds-of-thing-at-point-1:  Check first the tap-* property.
 ;;     For things (unquoted-)list, (non-nil-)symbol-name, region-or-word,
 ;;      (decimal-|hex-)number, string:
 ;;         put tap-* properties also.
 ;;     tap-put-thing-at-point-props: Use tap-bounds-of-number-at-point, not lambda.
 ;; 2012/08/21 dadams
 ;;     Added: tap-put-thing-at-point-props.
 ;;     Moved puts for list and number to tap-put-thing-at-point-props.
 ;;     tap-define-aliases-wo-prefix: Return non-nil so can use in Boolean test.
 ;; 2012/08/19 dadams
 ;;     Added: tap-symbol-name-at-point.
 ;;     tap(-bounds-of)-symbol-at-point(-with-bounds):
 ;;       Removed useless arg NON-NIL.  Adjust calls to them accordingly.
 ;;     tap-thing-at-point: Ensure it returns a string (or nil).
 ;;     tap-non-nil-symbol-name-at-point:
 ;;       Redefine, using tap-thing-at-point with emacs-lisp-mode-syntax-table.
 ;;     tap(-non-nil)-symbol-name-nearest-point: Return nil, not "", if none found.
 ;;     tap-sexp-nearest-point: Corrected: pass nil PREDICATE arg.
 ;;     Doc string improvements.
 ;; 2012/08/18 dadams
 ;;     tap-define-aliases-wo-prefix: Return non-nil so can use in Boolean guards.
 ;;     word-nearest-point -> tap-word-nearest-point (typo).
 ;; 2012/08/17 dadams
 ;;     Added: tap-define-aliases-wo-prefix, tap-redefine-std-fns.
 ;;     Added group thing-at-point-plus.  Use for defcustoms.
 ;;     Renamed fns & vars, adding prefix tap-.
 ;;     Do not redefine std stuff, except in tap-define-aliases-wo-prefix, tap-redefine-std-fns.
 ;; 2012/02/18 dadams
 ;;     thing/form-nearest-point-with-bounds:
 ;;       Fixed infloop: set [be]obp when finished sole line in both directions.
 ;; 2011/09/06 dadams
 ;;     thing/form-nearest-point-with-bounds: If only one line then do not try to access others.
 ;;     bounds-of-thing-at-point-1, thing-at-point, thing/form-nearest-point-with-bounds:
 ;;       Respect field boundaries.
 ;;     Define constrain-to-field, field-(beginning|end) as no-ops for older Emacs releases.
 ;; 2011/08/30 dadams
 ;;     Added: region-or-non-nil-symbol-name-nearest-point.
 ;;     region-or-*: Use region only if transient-mark-mode, non-empty (and active).
 ;; 2011/08/17 dadams
 ;;     list-at/nearest-point-with-bounds:
 ;;       Don't count `foo or 'foo as a list, i.e., (` foo) or (quote foo).
 ;; 2011/08/14 dadams
 ;;     bounds-of-thing-at-point-1:
 ;;       Tests for end need to use <, not <=.  If past the THING then should return nil.
 ;; 2011/07/08 dadams
 ;;     Removed: list-at/nearest-point.
 ;;     Added: (list|sexp)-(at|nearest)-point-with-bounds,
 ;;            bounds-of-(list|sexp)-(at|nearest)-point, list-at/nearest-point-with-bounds.
 ;;     (unquoted-)list-(at|nearest)-point(-as-string):
 ;;       Redefined using list-(at|nearest)-point-with-bounds.
 ;;     (put 'list 'bounds-of-thing-at-point 'bounds-of-list-at-point) - not nil.
 ;; 2011/05/24 dadams
 ;;     Added: (bounds-of-)string-at-point, string-nearest-point.
 ;; 2011/05/21 dadams
 ;;     bounds-of-thing-at-point-1: Synchronized with vanilla Emacs fix for bug #8667.
 ;; 2011/05/13 dadams
 ;;     Added redefinition of bounds-of-thing-at-point - fixed bug #8667.
 ;;       Removed old-bounds-of-thing-at-point.  Added: bounds-of-thing-at-point-1.
 ;;     Added: forward-whitespace-&-newlines.
 ;;     Added (put 'thing-at-point *) for unquoted-list, non-nil-symbol-name.
 ;;     Removed old eval-when-compile for Emacs before Emacs 20.
 ;; 2011/05/07 dadams
 ;;     Added: number-at-point-(decimal|hex) and aliases.
 ;;     Put (bounds-of-)thing-at-point properties: (hex-|decimal-)number-at-point.
 ;; 2011/05/05 dadams
 ;;     (put 'list 'bounds-of-thing-at-point nil)  See Emacs bug #8628.
 ;;     (put 'list 'thing-at-point 'list-at-point) - not really needed, though.
 ;;     bounds-of-thing-at-point: Mention in doc string that pre-Emacs 23 is buggy.
 ;; 2011/01/20 dadams
 ;;     *list-*-point: Improved doc strings.
 ;; 2011/01/04 dadams
 ;;     Removed autoload cookies from non def* sexps and non-interactive fns.
 ;;     Added autoload cookies for defcustom.
 ;; 2010/12/17 dadams
 ;;     Added: (unquoted-)list-(at|nearest)-point, list-at/nearest-point,
 ;;            unquoted-list-nearest-point-as-string.
 ;;     list-nearest-point: Redefined using list-at/nearest-point.
 ;; 2010/12/10 dadams
 ;;     form-at-point-with-bounds:
 ;;       Moved condition-case to around whole.  Let sexp be any format of nil.
 ;; 2010/01/24 dadams
 ;;     Added: region-or-word-nearest-point.
 ;; 2008/10/22 dadams
 ;;     Added: region-or-word-at-point.  Thx to Richard Riley.
 ;; 2007/07/15 dadams
 ;;     Added: thing/form-nearest-point-with-bounds,
 ;;            non-nil-symbol(-name)-(at|nearest)-point, near-point-(x|y)-distance.
 ;;     (thing|form)-nearest-point-with-bounds:
 ;;       Use thing/form-nearest-point-with-bounds, which: (1) accepts PRED arg,
 ;;         (2) respects near-point-(x|y)-distance, (3) fixed some logic.
 ;;     form-at-point-with-bounds:
 ;;       Distinguish between nil (no find) and "nil" object found.
 ;;     (bounds-of-)symbol-(at|nearest)-point(-with-bounds), :
 ;;       Added optional non-nil arg.
 ;;     Added beginning-op, end-op, and forward-op for defun type.
 ;; 2006/12/08 dadams
 ;;     Added: find-fn-or-var-nearest-point.
 ;; 2006/05/16 dadams
 ;;     Only require cl (at compile time) for Emacs < 20.
 ;;     Replace incf by setq...1+.
 ;; 2005/12/17 dadams
 ;;     symbol-name-nearest-point, form-at-point-with-bounds:
 ;;       Treat nil as legitimate symbol.
 ;; 1996/06/11 dadams
 ;;     bounds-of-symbol-at-point, bounds-of-symbol-nearest-point,
 ;;       symbol-at-point, symbol-at-point-with-bounds,
 ;;       symbol-name-nearest-point, symbol-nearest-point,
 ;;       symbol-nearest-point-with-bounds: No longer use a syntax-table
 ;;       arg.  Always dealing with elisp symbols, so use
 ;;       emacs-lisp-mode-syntax-table.
 ;; 1996/03/20 dadams
 ;;     1. Added redefinitions of thing-at-point, form-at-point, with optional
 ;;        syntax table arg.
 ;;     2. Added: thing-nearest-point-with-bounds,
 ;;        bounds-of-thing-nearest-point, thing-nearest-point,
 ;;        form-nearest-point-with-bounds,
 ;;        bounds-of-form-nearest-point, form-nearest-point,
 ;;        word-nearest-point, sentence-nearest-point,
 ;;        sexp-nearest-point, number-nearest-point,
 ;;        list-nearest-point.
 ;;     3. symbol-at-point: Added optional syntax table arg.
 ;;     4. symbol-nearest-point-with-bounds: Now defined in terms of
 ;;        form-nearest-point-with-bounds.
 ;;     5. bounds-of-form-at-point: Added args THING and PRED.
 ;; 1996/03/20 dadams
 ;;     1. Added redefinition of bounds-of-thing-at-point: New arg SYNTAX-TABLE.
 ;;     2. thing-at-point-with-bounds, form-at-point-with-bounds,
 ;;        bounds-of-form-at-point, symbol-at-point-with-bounds,
 ;;        bounds-of-symbol-at-point, symbol-nearest-point-with-bounds,
 ;;        bounds-of-symbol-nearest-point, symbol-nearest-point,
 ;;        symbol-name-nearest-point: New arg SYNTAX-TABLE.
 ;; 1996/03/08 dadams
 ;;     1. Added: thing-at-point-with-bounds, form-at-point-with-bounds,
 ;;        bounds-of-form-at-point, symbol-at-point-with-bounds,
 ;;        bounds-of-symbol-at-point
 ;;     2. symbol-at-point: 2nd arg ('symbolp) to form-at-point to ensure interned.
 ;;     3. Added: symbol-nearest-point-with-bounds, symbol-name-nearest-point,
 ;;        bounds-of-symbol-nearest-point, symbol-nearest-point.
 ;;     4. symbol-nearest-point-with-bounds: Use symbol-at-point-with-bounds, not
 ;;        bounds-of-thing-at-point.
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;; This program is free software; you can redistribute it and/or modify
 ;; it under the terms of the GNU General Public License as published by
 ;; the Free Software Foundation; either version 2, or (at your option)
 ;; any later version.

 ;; This program is distributed in the hope that it will be useful,
 ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
 ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ;; GNU General Public License for more details.

 ;; You should have received a copy of the GNU General Public License
 ;; along with this program; see the file COPYING.  If not, write to
 ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
 ;; Floor, Boston, MA 02110-1301, USA.
 ;;
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;
 ;;; Code:

 (require 'thingatpt)

 ;;;;;;;;;;;;;;;;;;;;;;

 ;;;###autoload
 (defgroup thing-at-point-plus nil
   "Enhancements to `thingatpt.el'."
   :prefix "tap-" :group 'applications :group 'development :group 'help
   :link `(url-link :tag "Send Bug Report"
           ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
 Thingatpt+ bug: \
 &body=Describe bug here, starting with `emacs -Q'.  \
 Don't forget to mention your Emacs and library versions."))
   :link '(url-link :tag "Download" "https://www.emacswiki.org/emacs/download/thingatpt%2b.el")
   :link '(url-link :tag "Description" "https://www.emacswiki.org/emacs/ThingAtPointPlus")
   :link '(emacs-commentary-link :tag "Commentary" "thingatpt+"))

 ;;;###autoload
 (defcustom tap-near-point-x-distance 50
   "*Maximum number of characters from point to search, left and right.
 Used typically by functions that invoke
 `tap-thing/form-nearest-point-with-bounds', and which provide default
 text for minibuffer input.  Such functions can also ignore or override
 this setting temporarily.

 See `tap-thing-nearest-point' for an explanation of the determination
 of \"nearness\"."
   :type 'integer :group 'thing-at-point-plus :group 'minibuffer)

 ;;;###autoload
 (defcustom tap-near-point-y-distance 5
   "*Maximum number of lines from point to search, up and down.
 To constrain search to the same line as point, set this to zero.
 Used typically by functions that invoke
 `tap-thing/form-nearest-point-with-bounds', and which provide default
 text for minibuffer input.  Such functions can also ignore or override
 this setting temporarily.

 See `tap-thing-nearest-point' for an explanation of the determination
 of \"nearness\"."
   :type 'integer :group 'thing-at-point-plus :group 'minibuffer)


 ;; Make these no-ops for Emacs versions that don't have it.  Easier than `fboundp' everywhere.
 (unless (fboundp 'constrain-to-field) (defun constrain-to-field (&rest _ignore) (point)))
 (unless (fboundp 'field-beginning)    (defalias 'field-beginning (symbol-function 'ignore)))
 (unless (fboundp 'field-end)          (defalias 'field-end (symbol-function 'ignore)))
 
 ;;; Utility Functions ------------------------------------------------


 ;; Same as `read-from-whole-string' (called `thingatpt--read-from-whole-string' starting
 ;; with Emacs 25) in library `thingatpt.el'.
 ;;
 (defun tap-read-from-whole-string (string)
   "Read a Lisp expression from STRING.
 Raise an error if the entire string was not used."
   (let* ((read-data  (read-from-string string))
	  (more-left (condition-case nil
                         ;; The call to `ignore' suppresses a compiler warning.
                         (progn (ignore (read-from-string (substring string (cdr read-data))))
				t)
                       (end-of-file nil))))
     (if more-left (error "Can't read whole string") (car read-data))))

 ;; Same as `icicle-string-match-p' in `icicles-fn.el'.
 ;; Do NOT alias `string-match-p', because that is a `defsubst'.
 ;;
 (defun tap-string-match-p (regexp string &optional start)
   "Like `string-match', but this saves and restores the match data."
   (save-match-data (string-match regexp string start)))

 ;; Same as `bmkp-looking-at-p' (`bookmark+-bmu.el'), `icicle-looking-at-p' (`icicles-mcmd.el').
 ;; Do not `defalias' to Emacs `looking-at-p' because that is a `defsubst'.
 (defun tap-looking-at-p (regexp)
   "Like `looking-at', but this saves and restores the match data."
   (save-match-data (looking-at regexp)))

 (defun tap-looking-back-p (regexp &optional limit greedy)
   "Like `looking-back', but this does not change the match data."
   (save-match-data
     (let ((start  (point))
           (pos    (save-excursion
                     (and (re-search-backward
                           (if (> emacs-major-version 21)
                               (concat "\\(?:" regexp "\\)\\=")
                             (concat "\\(" regexp "\\)\\="))
                           limit t)
                          (point)))))
       (if (and greedy  pos)
           (save-restriction
             (narrow-to-region (point-min) start)
             (while (and (> pos (point-min))
                         (save-excursion (goto-char pos)
                                         (backward-char 1)
                                         (tap-looking-at-p
                                          (if (> emacs-major-version 21)
                                              (concat "\\(?:" regexp "\\)\\'")
                                            (concat "\\(" regexp "\\)\\'")))))
               (setq pos  (1- pos)))
             (save-excursion (goto-char pos)
                             (tap-looking-at-p
                              (if (> emacs-major-version 21)
                                  (concat "\\(?:" regexp "\\)\\'")
				(concat "\\(" regexp "\\)\\'"))))))
       (not (null pos)))))
 
 ;;; THINGS -----------------------------------------------------------


 ;; If you invoke `tap-redefine-std-fns', this def replaces the original in `thingatpt.el'.
 ;;
 ;; 1. Fix Emacs bug #8667 (do not return an empty thing).
 ;; 2. Add optional argument SYNTAX-TABLE.
 ;; 3. Check first the property `tap-bounds-of-thing-at-point'.
 ;;
 ;; NOTE: Most of the other functions here are based on this function.
 ;;
 (defun tap-bounds-of-thing-at-point (thing &optional syntax-table)
   "Return the start and end locations for the THING at point.
 Return a consp (START . END), where START /= END.
 Return nil if no THING is found.

 THING is an Emacs Lisp symbol that specifies a type of syntactic
 entity.  THING examples include `word', `sentence', `defun'.  See the
 commentary of library `thingatpt.el' for how to define a symbol as a
 valid THING.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (if syntax-table
       (let ((buffer-syntax  (syntax-table)))
         (unwind-protect
              (progn (set-syntax-table syntax-table)
                     (tap-bounds-of-thing-at-point-1 thing))
           (set-syntax-table buffer-syntax)))
     (tap-bounds-of-thing-at-point-1 thing)))

 ;; This is the vanilla `bounds-of-thing-at-point', but with Emacs bugs #8667 and #9300 fixed.
 (defun tap-bounds-of-thing-at-point-1 (thing)
   "Helper for `tap-bounds-of-thing-at-point'.
 Do everything except handle the optional SYNTAX-TABLE arg."
   (let ((bounds-fn  (or (get thing 'tap-bounds-of-thing-at-point)
                         (get thing 'bounds-of-thing-at-point))))
     (if bounds-fn
         (funcall bounds-fn)
       (let ((orig  (point)))
         (condition-case nil
             (save-excursion
               ;; Try moving forward, then back.
               (funcall (or (get thing 'end-op) ; Move to end.
                            (lambda () (forward-thing thing 1))))
               (constrain-to-field nil orig)
               (funcall (or (get thing 'beginning-op) ; Move to beg.
                            (lambda () (forward-thing thing -1))))
               (constrain-to-field nil orig)
               (let ((beg  (point)))
                 (if (<= beg orig)
                     ;; If that brings us all the way back to ORIG,
                     ;; it worked.  But END may not be the real end.
                     ;; So find the real end that corresponds to BEG.
                     ;; FIXME: in which cases can `real-end' differ from `end'?
                     (let ((real-end  (progn (funcall
                                              (or (get thing 'end-op)
                                                  (lambda () (forward-thing thing 1))))
                                             (constrain-to-field nil orig)
                                             (point))))
                       (and (< orig real-end)  (< beg real-end)
                            (cons beg real-end)))
                   (goto-char orig)
                   ;; Try a second time, moving first backward and then forward,
                   ;; so that we can find a thing that ends at ORIG.
                   (funcall (or (get thing 'beginning-op) ; Move to beg.
				(lambda () (forward-thing thing -1))))
                   (constrain-to-field nil orig)
                   (funcall (or (get thing 'end-op) ; Move to end.
				(lambda () (forward-thing thing 1))))
                   (constrain-to-field nil orig)
                   (let ((end       (point))
                         (real-beg  (progn (funcall
                                            (or (get thing 'beginning-op)
						(lambda () (forward-thing thing -1))))
                                           (constrain-to-field nil orig)
                                           (point))))
                     (and (<= real-beg orig)  (< orig end)  (< real-beg end)
                          (cons real-beg end))))))
           (error nil))))))

 (defun tap-thing-at-point-with-bounds (thing &optional syntax-table)
   "Return the thing of type THING at point, plus its bounds.
 Return nil if no such thing is found.

 If found, return a cons (THE-THING START . END), where THE-THING is
 the `tap-thing-at-point'.  START and END are the buffer positions of
 THE-THING.

 See `tap-bounds-of-thing-at-point'.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (let ((bounds  (tap-bounds-of-thing-at-point thing syntax-table)))
     (and bounds  (cons (buffer-substring (car bounds) (cdr bounds)) bounds))))

 ;; If you invoke `tap-redefine-std-fns', this def replaces the original in `thingatpt.el'.
 ;;
 ;; 1. Add optional argument SYNTAX-TABLE.
 ;; 2. Check first the symbol property `tap-thing-at-point'.
 ;;
 (defun tap-thing-at-point (thing &optional no-properties syntax-table)
   "Return the THING at point.
 If no THING is present at point then return nil.

 THING is an Emacs Lisp symbol that specifies a type of syntactic
 entity.  THING examples include `symbol', `list', `sexp', `defun',
 `filename', `url', `email', `word', `sentence', `whitespace', `line',
 `number', and `page'.  See the commentary of library `thingatpt.el'
 for how to define a symbol as a valid THING.

 If THING has property `thing-at-point' then the property value should
 be a function.  Call the function with no arguments, and return the
 result.

 Otherwise, try to get the bounds of THING.  If successful, return the
 bounded string.

 Optional arg NO-PROPERTIES means that if a string is to be returned
 then it is first stripped of any text properties.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (let* ((thing-fn   (or (get thing 'tap-thing-at-point)  (get thing 'thing-at-point)))
          (something  (if thing-fn
                          (let* ((opoint  (point))
                                 (thg     (prog1 (funcall thing-fn)
                                            (constrain-to-field nil opoint))))
                            thg)
			(let ((bounds  (tap-bounds-of-thing-at-point thing syntax-table)))
                          (and bounds  (buffer-substring (car bounds) (cdr bounds)))))))
     (when (and (stringp something)  no-properties)
       (set-text-properties 0 (length something) nil something))
     something))

 (defun tap-thing-at-point-as-string (thing &optional no-properties syntax-table)
   "Return the THING at point as a string.
 If no THING is present at point then return nil.

 THING is an Emacs Lisp symbol that specifies a type of syntactic
 entity.  THING examples include `symbol', `list', `sexp', `defun',
 `filename', `url', `email', `word', `sentence', `whitespace', `line',
 `number', and `page'.  See the commentary of library `thingatpt.el'
 for how to define a symbol as a valid THING.

 If THING has property `thing-at-point' then the property value should
 be a function.  The function is called with no arguments.  If the
 return value of that function is a string or nil then that value is
 returned by this function also.  Otherwise, that value is converted to
 a string and returned.

 Optional arg NO-PROPERTIES means that if a string is to be returned
 then it is first stripped of any text properties.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (let* ((thing-fn  (or (get thing 'tap-thing-at-point)  (get thing 'thing-at-point)))
          (text      (if thing-fn
                         (let* ((opoint  (point))
				(thg     (prog1 (funcall thing-fn)
                                           (constrain-to-field nil opoint))))
                           (if (stringp thg)
                               thg
                             (and thg  (format "%s" thg))))
                       (let ((bounds  (tap-bounds-of-thing-at-point thing syntax-table)))
                         (and bounds  (buffer-substring (car bounds) (cdr bounds)))))))
     (when (and text  no-properties) (set-text-properties 0 (length text) nil text))
     text))

 (defun tap-thing-nearest-point-with-bounds (thing &optional syntax-table)
   "Return the THING nearest point, plus its bounds: (THING START . END).
 Return nil if no such THING is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 THING is the `tap-thing-nearest-point', a string.
 START and END are the buffer positions of THING - see
 `tap-bounds-of-thing-nearest-point'.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (tap-thing/form-nearest-point-with-bounds #'tap-thing-at-point-with-bounds
                                             thing nil syntax-table))

 (defun tap-thing/form-nearest-point-with-bounds (fn thing predicate syntax-table)
   "Thing or form nearest point, plus bounds: (THING-OR-FORM START . END).
 Helper for `tap-thing-nearest-point-with-bounds'
 and `tap-form-nearest-point-with-bounds'.

 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 FN is a function returning a thing or a form at point, and its bounds.
 Other args are as for `tap-thing-nearest-point-with-bounds'."
   (let ((opoint  (point)))
     (let ((f-or-t+bds  (prog1 (if predicate
                                   (funcall fn thing predicate syntax-table)
                                 (funcall fn thing syntax-table))
                          (constrain-to-field nil opoint)))
           (ind1        0)
           (ind2        0)
           (updown      1)
           (bobp        (or (eq (field-beginning nil) (point))  (bobp)))
           (eobp        (or (eq (field-end nil) (point))        (eobp)))
           (bolp        (or (eq (field-beginning nil) (point))  (bolp)))
           (eolp        (or (eq (field-end nil) (point))        (eolp)))
           (max-x       (abs tap-near-point-x-distance))
           (max-y       (if (zerop (save-excursion
                                     (goto-char (point-max))
                                     (prog1 (forward-line -1)
                                       (constrain-to-field nil opoint))))
                            (abs tap-near-point-y-distance)
                          1)))           ; Only one line.
       ;; IND2: Loop over lines (alternately up and down).
       (while (and (<= ind2 max-y)  (not f-or-t+bds)  (not (and bobp  eobp)))
         (setq updown  (- updown))       ; Switch directions up/down (1/-1).
         (save-excursion
           (when (> max-y 1)             ; Skip this if only one line.
             (condition-case ()
                 (prog1 (previous-line (* updown ind2)) ; 0, 1, -1, 2, -2, ...
                   (constrain-to-field nil opoint))
               (beginning-of-buffer (setq bobp  t))
               (end-of-buffer (setq eobp  t))
               (error nil)))
           ;; Do not try to go beyond buffer or field limit.
           (unless (or (and bobp  (> (* updown ind2) 0)) ; But do it for ind2=0.
                       nil)              ; $$$$$$ (and eobp  (< updown 0))) ; No, loop OK here.
             (setq f-or-t+bds  (prog1 (if predicate
                                          (funcall fn thing predicate syntax-table)
					(funcall fn thing syntax-table))
                                 (constrain-to-field nil opoint))
                   bolp        (or (eq (field-beginning nil) (point))  (bolp))
                   eolp        (or (eq (field-end nil) (point))        (eolp))
                   ind1        0)
             (save-excursion
               ;; IND1: Loop over chars in same line (alternately left and right),
               ;; until either found thing/form or both line limits reached.
               (while (and (not (and bolp eolp))  (<= ind1 max-x)  (not f-or-t+bds))
                 (unless bolp (save-excursion ; Left.
				(setq bolp        (prog1 (forward-char-same-line (- ind1))
                                                    (constrain-to-field nil opoint))
                                      f-or-t+bds  (if predicate
                                                      (funcall fn thing predicate syntax-table)
                                                    (funcall fn thing syntax-table)))
				(constrain-to-field nil opoint)))
                 (unless (or f-or-t+bds  eolp) ; Right.
                   (save-excursion
                     (setq eolp        (prog1 (forward-char-same-line ind1)
                                         (constrain-to-field nil opoint))
                           f-or-t+bds  (if predicate
                                           (funcall fn thing predicate syntax-table)
                                         (funcall fn thing syntax-table)))
                     (constrain-to-field nil opoint)))
                 (setq ind1  (1+ ind1)))
               (setq bobp  (or (eq (field-beginning nil) (point))
                               (bobp)
                               (< max-y 2)) ; If only one line, fake `bobp'.
                     eobp  (or (eq (field-end nil) (point))
                               (eobp)
                               (< max-y 2)))))) ; If only one line, fake `eobp'.
         ;; Increase search line distance every second time (once up, once down).
         (when (and (> max-y 1)  (or (< updown 0)  (zerop ind2))) ; 0,1,1,2,2...
           (setq ind2  (1+ ind2))))
       f-or-t+bds)))

 (defun tap-bounds-of-thing-nearest-point (thing &optional syntax-table)
   "Return the start and end locations for the THING nearest point.
 Return a consp (START . END), where START /= END.
 Return nil if no such THING is found.

 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (let ((thing+bds  (tap-thing-nearest-point-with-bounds thing syntax-table)))
     (and thing+bds
          (cdr thing+bds))))

 (defun tap-thing-nearest-point (thing &optional syntax-table)
   "Return the THING nearest point, if any, else nil.
 The search for the THING is bounded by options
 `tap-near-point-x-distance' and `tap-near-point-y-distance'.

 \"Nearest\" to point is determined as follows:

   The nearest THING on the same line is returned, if there is any.
       Between two THINGs equidistant from point on the same line, the
       leftmost is considered nearer.
   Otherwise, neighboring lines are tried in sequence:
   previous, next, 2nd previous, 2nd next, 3rd previous, 3rd next, etc.
       This means that between two THINGs equidistant from point in
       lines above and below it, the THING in the line above point
       (previous Nth) is considered nearer to it.

 However, for some THINGs whitespace between THINGs might be considered
 insignificant, as well as the amount of it.  This means that if point
 is between two THINGs and surrounded by whitespace then the \"nearest\"
 THING returned might not be the one that is absolutely closest.

 See also `tap-thing-at-point'.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (let ((thing+bds  (tap-thing-nearest-point-with-bounds thing syntax-table)))
     (and thing+bds
          (car thing+bds))))
 
 ;;; FORMS, SEXPS -----------------------------------------------------

 (defun tap-form-at-point-with-bounds (&optional thing predicate syntax-table)
   "Return the Lisp THING at point, plus its bounds: (FORM START . END).
 Return nil if no form is found.
 THING must be readable as a Lisp entity, to give FORM - see
  `tap-form-at-point'.
 START and END are the buffer positions of FORM.
 Optional args:
   THING is the kind of form desired (default: `sexp').
   PREDICATE is a predicate that the form must satisfy to qualify.
   SYNTAX-TABLE is a syntax table to use."
   (condition-case nil                   ; E.g. error if tries to read a dot (`.').
       (let* ((thing+bds  (tap-thing-at-point-with-bounds (or thing  'sexp) syntax-table))
              (bounds     (cdr thing+bds))
              (sexp       (and bounds  (tap-read-from-whole-string (car thing+bds)))))
         (and bounds  (or (not predicate)  (funcall predicate sexp))
              (cons sexp bounds)))
     (error nil)))

 ;; Essentially an alias for the default case.
 (defun tap-sexp-at-point-with-bounds (&optional predicate syntax-table)
   "Return the sexp at point, plus its bounds: (SEXP START . END)
 Return nil if no sexp is found.
 SEXP is an Emacs Lisp entity, the result of reading the textual sexp
 at point.  See `sexp-at-point'.

 START and END are the buffer positions of SEXP.
 Optional args are the same as for `tap-form-at-point-with-bounds'."
   (tap-form-at-point-with-bounds 'sexp predicate syntax-table))

 (defun tap-bounds-of-form-at-point (&optional thing predicate syntax-table)
   "Return the start and end locations for the THING at point.
 THING must be readable as a Lisp entity - see `tap-form-at-point'.
 Return a consp (START . END), where START /= END.
 Return nil if no such THING is found.
 Optional args:
   THING is the kind of form desired (default: `sexp').
   PREDICATE is a predicate that the form must satisfy to qualify.
   SYNTAX-TABLE is a syntax table to use."
   (let ((form+bds  (tap-form-at-point-with-bounds thing predicate syntax-table)))
     (and form+bds
          (cdr form+bds))))

 ;; Essentially an alias for the default case.
 (defun tap-bounds-of-sexp-at-point (&optional predicate syntax-table)
   "Return the start and end locations for the sexp at point.
 SEXP is an Emacs Lisp entity, the result of reading the textual sexp
 at point.  See `sexp-at-point'.
 Return a consp (START . END), where START /= END.
 Return nil if no sexp is found.
 Optional args are the same as for `tap-bounds-of-form-at-point'."
   (tap-bounds-of-form-at-point 'sexp predicate syntax-table))


 ;; If you invoke `tap-redefine-std-fns', this def replaces the original in `thingatpt.el'.
 ;;
 ;; Add optional argument SYNTAX-TABLE.
 ;;
 (defun tap-form-at-point (&optional thing predicate syntax-table)
   "Return the form at point, if any, else nil.
 This is an Emacs Lisp entity, not necessarily a string.  THING must be
 readable as a Lisp entity, or else nil is returned.

 Reading THING and returning the resulting Lisp entity is the main
 difference between this function and `tap-thing-at-point-as-string'.
 The other difference is the use of PREDICATE.

 Optional args:
   THING is the kind of form desired (default: `sexp').
   PREDICATE is a predicate that the form must satisfy to qualify.
   SYNTAX-TABLE is a syntax table to use."
   (let ((form  (condition-case nil
                    (tap-read-from-whole-string
                     (tap-thing-at-point-as-string (or thing  'sexp) nil syntax-table))
                  (error nil))))
     (and (or (not predicate)  (funcall predicate form))
          form)))

 (defun tap-form-nearest-point-with-bounds (&optional thing predicate syntax-table)
   "Return the form nearest point, plus its bounds: (FORM START . END).
 Return nil if no form is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 FORM is from `tap-form-nearest-point'.
 START and END are the buffer positions of FORM.
 Optional args:
   THING is the kind of form desired (default: `sexp').
   PREDICATE is a predicate that the form must satisfy to qualify.
   SYNTAX-TABLE is a syntax table to use."
   (tap-thing/form-nearest-point-with-bounds #'tap-form-at-point-with-bounds
                                             thing predicate syntax-table))

 ;; Essentially an alias for the default case.
 (defun tap-sexp-nearest-point-with-bounds (&optional predicate syntax-table)
   "Return the sexp nearest point, plus its bounds: (SEXP START . END).
 Return nil if no sexp is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 SEXP is an Emacs Lisp entity, the result of reading a textual sexp
  near point.  See `tap-sexp-nearest-point'.
 START and END are the buffer positions of SEXP.
 Optional args are the same as for
 `tap-form-nearest-point-with-bounds'."
   (tap-form-nearest-point-with-bounds 'sexp predicate syntax-table))

 (defun tap-bounds-of-form-nearest-point (&optional thing predicate syntax-table)
   "Return the start and end locations for the form nearest point.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.
 See `tap-form-nearest-point'.

 Return a consp (START . END), where START /= END.
 Return nil if no form is found.
 Arguments are the same as for `tap-form-nearest-point-with-bounds'."
   (let ((form+bds  (tap-form-nearest-point-with-bounds thing predicate syntax-table)))
     (and form+bds
          (cdr form+bds))))

 ;; Essentially an alias for the default case.
 (defun tap-bounds-of-sexp-nearest-point (&optional predicate syntax-table)
   "Return the start and end locations for the sexp nearest point.
 See `tap-sexp-nearest-point'.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Return a consp (START . END), where START /= END.
 Return nil if no form is found.
 Optional args are the same as for `tap-bounds-of-sexp-nearest-point'."
   (tap-bounds-of-form-nearest-point 'sexp predicate syntax-table))

 (defun tap-form-nearest-point (&optional thing predicate syntax-table)
   "Return the form nearest point, if any, else nil.
 This is an Emacs Lisp entity, not necessarily a string.  THING must be
 readable as a Lisp entity, or else nil is returned.

 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Reading THING and returning the resulting Lisp entity is the main
 difference between this function and `tap-thing-nearest-point'.  The
 other difference is the use of PREDICATE.

 Optional args:
   THING is the kind of form desired (default: `sexp').
   PREDICATE is a predicate that the form must satisfy to qualify.
   SYNTAX-TABLE is a syntax table to use."
   (let ((form+bds  (tap-form-nearest-point-with-bounds thing predicate syntax-table)))
     (and form+bds
          (car form+bds))))
 
 ;;; SYMBOLS ----------------------------------------------------------

 (defun tap-symbol-at-point-with-bounds ()
   "Return the Emacs Lisp symbol nearest point, plus its bounds.
 Return (SYMBOL START . END), or nil if no symbol is found.
 Note that nil is also returned if the symbol at point is `nil'.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 SYMBOL is the symbol from `tap-symbol-at-point'.
 START and END are the buffer positions of SYMBOL."
   (tap-form-at-point-with-bounds 'symbol 'symbolp emacs-lisp-mode-syntax-table))

 (defun tap-bounds-of-symbol-at-point ()
   "Return the start and end locations for the Emacs Lisp symbol at point.
 See `tap-symbol-at-point'.
 Return a consp (START . END), where START /= END.
 Return nil if no symbol is found or if the symbol at point is `nil'."
   (let ((symb+bds  (tap-symbol-at-point-with-bounds)))
     (and symb+bds
          (cdr symb+bds))))


 ;; If you invoke `tap-redefine-std-fns', this def replaces the original in `thingatpt.el'.
 ;;
 ;; Use `tap-form-at-point', passing `emacs-lisp-mode-syntax-table'.
 ;; (Vanilla `symbol-at-point' interns (thing-at-point 'symbol).)
 ;;
 (defun tap-symbol-at-point ()
   "Return the Emacs Lisp symbol at point, or nil if none.
 Note that nil is also returned if the symbol at point is `nil'.

 Some related functions:
  `tap-symbol-nearest-point' returns the symbol nearest point,
    or nil if none.
  `tap-symbol-name-nearest-point' returns the name of
    `tap-symbol-nearest-point' as a string,
    or nil if none.
  `symbol-name-before-point' returns the string naming the symbol at or
    before point (even if it is on a previous line).
  `word-at-point' returns the word at point,
    or nil if none.
  `word-before-point' returns the word (a string) at or before cursor.
  `tap-word-nearest-point' returns the word nearest point,
    or nil if none.
 All but the first return strings, not (non-nil) symbols."
   ;; Needs to satisfy both: (1) symbol syntax in Emacs Lisp mode, and (2) be interned.
   (tap-form-at-point 'symbol 'symbolp emacs-lisp-mode-syntax-table))

 (defun tap-symbol-nearest-point-with-bounds (&optional non-nil)
   "Return (SYMBOL START . END) with START and END of SYMBOL.
 SYMBOL is the `tap-symbol-nearest-point'.
 If optional arg NON-NIL is non-nil, then the nearest symbol other
   than `nil' is sought.
 Return nil if no such Emacs Lisp symbol is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'."
   (tap-form-nearest-point-with-bounds 'symbol
                                       (if non-nil
                                           (lambda (sym) (and sym  (symbolp sym)))
                                         'symbolp)
                                       emacs-lisp-mode-syntax-table))

 (defun tap-bounds-of-symbol-nearest-point (&optional non-nil)
   "Return the start and end locations for the Lisp symbol nearest point.
 See `tap-symbol-nearest-point'.
 Return a consp (START . END), where START /= END.
 Return nil if no such Emacs Lisp symbol is found.
 If optional arg NON-NIL is non-nil, then seek the nearest symbol other
 than `nil'.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'."
   (let ((symb+bds  (tap-symbol-nearest-point-with-bounds non-nil)))
     (and symb+bds
          (cdr symb+bds))))

 (defun tap-symbol-nearest-point (&optional non-nil)
   "Return the Emacs Lisp symbol nearest point, or nil if none.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 If optional arg NON-NIL is non-nil, then seek the nearest symbol other
   than `nil'.

 Some related functions:
  `tap-symbol-at-point' returns the symbol under the cursor,
    or nil if none.
  `tap-symbol-name-nearest-point' returns the name of
    `tap-symbol-nearest-point' as a string,
    or nil if none.
  `symbol-name-before-point' returns the string naming the symbol at or
    before the cursor (even if it is on a previous line).
  `word-at-point' returns the word at point,
    or nil if none.
  `word-before-point' returns the word at or before point as a string.
  `tap-word-nearest-point' returns the word nearest point,
    or nil if none.
 All but the first return strings, not (non-nil) symbols."
   (let ((symb+bds  (tap-symbol-nearest-point-with-bounds non-nil)))
     (and symb+bds
          (car symb+bds))))

 (defun tap-non-nil-symbol-nearest-point ()
   "Return the Emacs Lisp symbol other than `nil' nearest point.
 Return nil if none is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Some related functions:
  `tap-symbol-at-point' returns the symbol under the cursor,
    or nil if none.
  `tap-symbol-name-nearest-point' returns the name of
    `tap-symbol-nearest-point' as a string,
    or nil if none.
  `symbol-name-before-point' returns the string naming the symbol at or
    before the cursor (even if it is on a previous line).
  `word-at-point' returns the word at point,
    or nil if none.
  `tap-word-nearest-point' returns the word nearest point,
    or nil if none.
  `word-before-point' returns the word at or before point as a string.
 All but the first return strings, not (non-nil) symbols."
   (let ((symb+bds  (tap-symbol-nearest-point-with-bounds t)))
     (and symb+bds
          (car symb+bds))))
 
 ;;; LISTS ------------------------------------------------------------

 (defun tap-list-at/nearest-point-with-bounds (at/near &optional up unquotedp)
   "Helper for `tap-list-at-point-with-bounds' and similar functions.
 AT/NEAR is a function called to grab the initial list and its bounds.
 UP (default: 0) is the number of list levels to go up to start with.
 Non-nil UNQUOTEDP means remove the car if it is `quote' or
  `backquote-backquote-symbol'.

 Return (LIST START . END) with START and END of the non-empty LIST.
 Return nil if no non-empty list is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'."
   (save-excursion
     (unless (eq at/near 'tap-sexp-at-point-with-bounds)
       ;; Skip over whitespace, including newlines.
       ;; "Nearest" here treats all contiguous whitespace as if it were a single char.
       (cond ((tap-looking-at-p   "\\(\\s-*\\|[\n]*\\)\\s(") (skip-syntax-forward "->"))
             ((tap-looking-back-p "\\s)\\(\\s-*\\|[\n]*\\)") (skip-syntax-backward "->"))))
     (let (strg-end)
       (while (setq strg-end  (if (> emacs-major-version 24)
                                  (nth 3 (syntax-ppss)) ; Emacs bug #20732
				(in-string-p)))
         (skip-syntax-forward "^\"")     ; Skip past string element of list.
         (skip-syntax-forward "\"")))    ; Skip past new string opening, `"', into next string.
     (let ((sexp+bnds  (funcall at/near)))
       (condition-case nil               ; Handle an `up-list' error.
           (progn
             (when up
               (up-list (- up))
               (setq sexp+bnds  (tap-sexp-at-point-with-bounds)))
             (while (or (not (consp (car sexp+bnds)))
			(and (memq (caar sexp+bnds) (list backquote-backquote-symbol 'quote))
                             (not (listp (cadr (car sexp+bnds))))))
               (up-list -1)
               (setq sexp+bnds  (tap-sexp-at-point-with-bounds)))
             (when (and unquotedp  (consp (car sexp+bnds))
			(memq (caar sexp+bnds) (list backquote-backquote-symbol 'quote)))
               (cond ((eq 'quote (caar sexp+bnds))
                      (setq sexp+bnds  (cons (cadr (car sexp+bnds))
                                             (cons (+ 5 (cadr sexp+bnds)) (cddr sexp+bnds)))))
                     ((eq backquote-backquote-symbol (caar sexp+bnds))
                      (setq sexp+bnds  (cons (cadr (car sexp+bnds))
                                             (cons (+ 1 (cadr sexp+bnds)) (cddr sexp+bnds)))))))
             (while (not (consp (car sexp+bnds)))
               (up-list -1)
               (setq sexp+bnds  (tap-sexp-at-point-with-bounds))))
         (error (setq sexp+bnds  nil)))
       sexp+bnds)))

 (defun tap-list-at-point-with-bounds (&optional up unquotedp)
   "Return (LIST START . END), boundaries of the `tap-list-at-point'.
 Return nil if no non-empty list is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 UP (default: 0) is the number of list levels to go up to start with.
 Non-nil UNQUOTEDP means remove the car if it is `quote' or
  `backquote-backquote-symbol'."
   (tap-list-at/nearest-point-with-bounds 'tap-sexp-at-point-with-bounds up unquotedp))

 (defun tap-list-nearest-point-with-bounds (&optional up unquotedp)
   "Return (LIST START . END), boundaries of the `tap-list-nearest-point'.
 Return nil if no non-empty list is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 UP (default: 0) is the number of list levels to go up to start with.
 Non-nil UNQUOTEDP means remove the car if it is `quote' or
  `backquote-backquote-symbol'."
   (tap-list-at/nearest-point-with-bounds 'tap-sexp-nearest-point-with-bounds up unquotedp))

 (defun tap-bounds-of-list-at-point (&optional up unquotedp)
   "Return the start and end locations for the non-empty list at point.
 See `tap-list-at-point'.
 Return a consp (START . END), where START /= END.
 Return nil if no non-empty list is found.
 Optional args:
   UP (default: 0) is the number of list levels to go up to start with.
   Non-nil UNQUOTEDP means remove the car if it is `quote' or
  `backquote-backquote-symbol'."
   (let ((thing+bds  (tap-list-at-point-with-bounds up unquotedp)))
     (and thing+bds
          (cdr thing+bds))))

 (defun tap-bounds-of-list-nearest-point (&optional up unquotedp)
   "Return start and end locations for the non-empty list nearest point.
 See `tap-list-nearest-point'.
 Return a consp (START . END), where START /= END.
 Return nil if no non-empty list is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Optional args:
   UP (default: 0) is the number of list levels to go up to start with.
   Non-nil UNQUOTEDP means remove the car if it is `quote' or
  `backquote-backquote-symbol'."
   (let ((thing+bds  (tap-list-nearest-point-with-bounds up unquotedp)))
     (and thing+bds
          (cdr thing+bds))))


 (put 'list 'tap-thing-at-point 'tap-list-at-point)
 (put 'list 'tap-bounds-of-thing-at-point 'tap-bounds-of-list-at-point)


 ;; If you invoke `tap-redefine-std-fns' or `tap-put-thing-at-point-props', this definition
 ;; replaces the original in `thingatpt.el'.
 ;;
 ;; 1. Added optional arg UP.
 ;; 2. Better, consistent behavior.
 ;; 3. Let `(tap-)bounds-of-thing-at-point' do its job.
 ;;
 (defun tap-list-at-point (&optional up)
   "Return the non-nil list at point, or nil if none.
 If inside a list, return the enclosing list.

 UP (default: 0) is the number of list levels to go up to start with.

 Note: If point is inside a string that is inside a list:
  This can sometimes return nil.
  This can sometimes return an incorrect list value if the string or
  nearby strings contain parens.
  (These are limitations of function `up-list'.)"
   (let ((list+bds  (tap-list-at-point-with-bounds up)))
     (and list+bds  (car list+bds))))


 (put 'unquoted-list 'thing-at-point     'tap-unquoted-list-at-point)
 (put 'unquoted-list 'tap-thing-at-point 'tap-unquoted-list-at-point)

 (defun tap-unquoted-list-at-point (&optional up)
   "Return the non-nil list at point, or nil if none.
 Same as `tap-list-at-point', but removes the car if it is `quote' or
  `backquote-backquote-symbol' (\`).
 UP (default: 0) is the number of list levels to go up to start with."
   (let ((list+bds  (tap-list-at-point-with-bounds up 'UNQUOTED)))
     (and list+bds  (car list+bds))))

 ;;; This simple definition is nowhere near as good as the one below.
 ;;;
 ;;; (defun tap-list-nearest-point (&optional syntax-table)
 ;;;   "Return the list nearest to point, if any, else nil.
 ;;; This does not distinguish between finding no list and finding
 ;;; the empty list.  \"Nearest\" to point is determined as for
 ;;; `tap-thing-nearest-point'.
 ;;; Optional arg SYNTAX-TABLE is a syntax table to use."
 ;;;   (tap-form-nearest-point 'list 'listp syntax-table))

 (defun tap-list-nearest-point (&optional up)
   "Return the non-nil list nearest point, or nil if none.
 Same as `tap-list-at-point', but returns the nearest list.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 UP (default: 0) is the number of list levels to go up to start with."
   (let ((list+bds  (tap-list-nearest-point-with-bounds up)))
     (and list+bds  (car list+bds))))

 (defun tap-unquoted-list-nearest-point (&optional up)
   "Return the non-nil list nearest point, or nil if none.
 UP (default: 0) is the number of list levels to go up to start with.
 Same as `tap-list-nearest-point', but removes the car if it is
 `quote' or `backquote-backquote-symbol' (\`)."
   (let ((list+bds  (tap-list-nearest-point-with-bounds up 'UNQUOTED)))
     (and list+bds
          (car list+bds))))


 ;; The following functions return a string, not a list.
 ;; They can be useful to pull a sexp into minibuffer.

 (defun tap-list-nearest-point-as-string (&optional up)
   "Return a string of the non-nil list nearest point, or \"\" if none.
 If not \"\", the list in the string is what is returned by
  `tap-list-nearest-point'.
 UP (default: 0) is the number of list levels to go up to start with."
   (let ((list+bds  (tap-list-nearest-point-with-bounds up)))
     (if list+bds (format "%s" (car list+bds)) "")))

 (defun tap-unquoted-list-nearest-point-as-string (&optional up)
   "Return a string of the non-nil list nearest point, or \"\" if none.
 If not \"\", the list in the string is what is returned by
  `tap-unquoted-list-nearest-point'.
 UP (default: 0) is the number of list levels to go up to start with."
   (let ((list+bds  (tap-list-nearest-point-with-bounds up 'UNQUOTED)))
     (if list+bds (format "%s" (car list+bds)) "")))

 (defun tap-bounds-of-list-contents-at-point ()
   "Return the start and end locations for the list contents at point.
 Same as `tap-bounds-of-list-at-point', except that this does not
 include the enclosing `(' and `)' characters."
   (let ((full  (tap-bounds-of-list-at-point)))
     (and full  (cons (1+ (car full)) (1- (cdr full))))))

 ;; Add this so that, for example, `thgcmd-defined-thing-p' in
 ;; `thing-cmds.el' recognizes `list-contents' as a THING.
 (put 'list-contents 'bounds-of-thing-at-point 'tap-bounds-of-list-contents-at-point)

 (defun tap-list-contents-at-point ()
   "Return the contents of the list at point as a string, or nil if none.
 Same as `tap-list-at-point-as-string', except that this does not
 include the enclosing `(' and `)' characters."
   (let ((bounds  (tap-bounds-of-list-contents-at-point)))
     (and bounds  (buffer-substring (car bounds) (cdr bounds)))))

 (defun tap-list-contents-nearest-point ()
   "Return the contents of the list nearest point as a string, or nil.
 See `tap-list-contents-at-point'.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'."
   (let ((full  (tap-bounds-of-thing-nearest-point 'list)))
     (and full  (buffer-substring (1+ (car full)) (1- (cdr full))))))
 
 ;;; SYMBOL NAMES, WORDS, SENTENCES, etc. -----------------------


 (put 'non-nil-symbol-name 'thing-at-point     'tap-non-nil-symbol-name-at-point)
 (put 'non-nil-symbol-name 'tap-thing-at-point 'tap-non-nil-symbol-name-at-point)

 (defun tap-non-nil-symbol-name-at-point ()
   "String naming a non-nil Emacs Lisp symbol at point, or nil if none."
   (let ((name  (tap-thing-at-point 'symbol nil emacs-lisp-mode-syntax-table)))
     (and (not (equal "nil" name))  name)))


 (put 'symbol-name 'thing-at-point     'tap-symbol-name-at-point)
 (put 'symbol-name 'tap-thing-at-point 'tap-symbol-name-at-point)

 (defun tap-symbol-name-at-point ()
   "String naming the Emacs Lisp symbol at point, or nil if none.
 The symbol might be `nil', so that \"nil\" is returned.
 See also `tap-non-nil-symbol-name-at-point'."
   (tap-thing-at-point 'symbol emacs-lisp-mode-syntax-table))

 (defun tap-symbol-name-nearest-point ()
   "String naming the Emacs Lisp symbol nearest point, or nil if none.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'."
   ;; We do it this way to be able to pick symbol `nil' (name "nil").
   (let ((symb+bds  (tap-symbol-nearest-point-with-bounds nil)))
     (and symb+bds (symbol-name (car symb+bds)))))

 (defun tap-non-nil-symbol-name-nearest-point ()
   "String naming the Emacs Lisp symbol nearest point, or nil if none.
 Returns the name of the nearest symbol other than `nil'.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'."
   (let ((symb+bds  (tap-symbol-nearest-point-with-bounds t)))
     (and symb+bds (symbol-name (car symb+bds)))))

 (defun tap-region-or-non-nil-symbol-name-nearest-point (&optional quote-it-p)
   "Return non-empty active region or symbol nearest point, or nil if none.
 Non-nil QUOTE-IT-P means wrap the region text in double-quotes (\").
 The name of the nearest symbol other than `nil' is used.
 See `tap-non-nil-symbol-name-nearest-point'."
   (if (and transient-mark-mode mark-active
            (not (eq (region-beginning) (region-end))))
       (let ((region-text  (buffer-substring-no-properties (region-beginning) (region-end))))
         (if quote-it-p
             (concat "\"" region-text "\"")
           region-text))
     (tap-non-nil-symbol-name-nearest-point)))

 (defun tap-word-nearest-point (&optional syntax-table)
   "Return the word (a string) nearest to point, if any, else nil.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (tap-thing-nearest-point 'word syntax-table))

 (defun tap-region-or-word-nearest-point (&optional syntax-table)
   "Return non-empty active region or word nearest point.
 See `tap-word-nearest-point'."
   (if (and transient-mark-mode mark-active
            (not (eq (region-beginning) (region-end))))
       (buffer-substring-no-properties (region-beginning) (region-end))
     (tap-word-nearest-point syntax-table)))


 (put 'region-or-word 'thing-at-point     'tap-region-or-word-at-point)
 (put 'region-or-word 'tap-thing-at-point 'tap-region-or-word-at-point)

 (defun tap-region-or-word-at-point ()
   "Return non-empty active region or word at or adjacent to point."
   (if (and transient-mark-mode mark-active
            (not (eq (region-beginning) (region-end))))
       (buffer-substring-no-properties (region-beginning) (region-end))
     (if (> emacs-major-version 21)
         (current-word 'STRICT 'REALLY-WORD)
       (current-word 'STRICT))))


 (when (fboundp 'color-defined-p)        ; Emacs 21+
   (put 'color 'thing-at-point               'tap-color-at-point)
   (put 'color 'tap-thing-at-point           'tap-color-at-point)
   (put 'color 'bounds-of-thing-at-point     'tap-bounds-of-color-at-point)
   (put 'color 'tap-bounds-of-thing-at-point 'tap-bounds-of-color-at-point)

   (defun tap-color-at-point ()
     "Return the color name or RGB code (with prefix `#') at point."
     (let ((word  (with-syntax-table (copy-syntax-table (syntax-table))
                    (modify-syntax-entry ?# "w") ; Make `#' a word constituent.
                    (word-at-point))))
       (and word  (color-defined-p word)  word)))

   (defun tap-bounds-of-color-at-point ()
     "Return the bounds of the color name at point.
 The color name can also be an RGB code (with prefix `#').
 Return nil if no color name is found."
     (let ((word+bnds  (with-syntax-table (copy-syntax-table (syntax-table))
                         (modify-syntax-entry ?# "w") ; Make `#' a word constituent.
                         (thing-at-point-with-bounds 'word))))
       (and word+bnds  (color-defined-p (car word+bnds))  (cdr word+bnds))))

   (defun tap-color-nearest-point-with-bounds ()
     "Return the color name nearest point, plus its bounds: (COLOR START . END).
 Return nil if no color name is found.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 COLOR is a color name or RGB code (with prefix `#').
  See `tap-color-nearest-point'.
 START and END are the buffer positions of COLOR."
     (tap-thing-nearest-point-with-bounds 'color))

   (defun tap-color-nearest-point ()
     "Return the color name or RGB code (with prefix `#') nearest point.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'."
     (let ((color+bds  (tap-color-nearest-point-with-bounds)))
       (and color+bds  (car color+bds)))))

 (defun tap-sentence-nearest-point (&optional syntax-table)
   "Return the sentence (a string) nearest to point, if any, else \"\".
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (tap-thing-nearest-point 'sentence syntax-table))

 (defun tap-sexp-nearest-point (&optional syntax-table)
   "Return the sexp nearest point, if any, else \"\".
 This is an Emacs Lisp entity, the result of reading a textual sexp
 near point.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (tap-form-nearest-point 'sexp nil syntax-table))

 (defun tap-number-nearest-point (&optional syntax-table)
   "Return the number nearest to point, if any, else nil.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.

 Optional arg SYNTAX-TABLE is a syntax table to use."
   (tap-form-nearest-point 'sexp 'numberp syntax-table))


 ;; `defun' type.  These are defined in recent `thingatpt.el', but not for older versions.
 (unless (get 'defun 'beginning-op) (put 'defun 'beginning-op 'beginning-of-defun))
 (unless (get 'defun 'end-op)       (put 'defun 'end-op       'end-of-defun))
 (unless (get 'defun 'forward-op)   (put 'defun 'forward-op   'end-of-defun))


 (put 'number 'tap-bounds-of-thing-at-point 'tap-bounds-of-number-at-point)

 (defun tap-bounds-of-number-at-point ()
   "Return the bounds of the number represented by the numeral at point.
 Return nil if none is found."
   (and (number-at-point)  (tap-bounds-of-thing-at-point 'sexp)))


 ;;; `number-at-point' returns the char value when point is on char syntax.
 ;;; E.g., when on ?A it returns 65 (not nil); when on ?\A-\^@ it returns 4194304.
 ;;; So we add these functions, which do what you would normally expect.


 (put 'decimal-number 'bounds-of-thing-at-point     'tap-bounds-of-number-at-point-decimal)
 (put 'decimal-number 'tap-bounds-of-thing-at-point 'tap-bounds-of-number-at-point-decimal)

 (defun tap-bounds-of-number-at-point-decimal ()
   "Return bounds of number represented by the decimal numeral at point.
 Return nil if none is found."
   (and (tap-number-at-point-decimal)  (tap-bounds-of-thing-at-point 'sexp)))


 (put 'decimal-number 'thing-at-point     'tap-number-at-point-decimal)
 (put 'decimal-number 'tap-thing-at-point 'tap-number-at-point-decimal)

 (defalias 'decimal-number-at-point 'tap-number-at-point-decimal)
 (defun tap-number-at-point-decimal ()
   "Return the number represented by the decimal numeral at point.
 Return nil if none is found."
   (let ((strg  (tap-thing-at-point 'sexp)))
     (and (stringp strg)
          (tap-string-match-p "\\`[0-9]+\\'" strg)
          (string-to-number strg))))


 (put 'hex-number 'bounds-of-thing-at-point     'tap-bounds-of-number-at-point-hex)
 (put 'hex-number 'tap-bounds-of-thing-at-point 'tap-bounds-of-number-at-point-hex)

 (defun tap-bounds-of-number-at-point-hex ()
   "Return bounds of number represented by the hexadecimal numeral at point.
 Return nil if none is found."
   (and (tap-number-at-point-hex)  (tap-bounds-of-thing-at-point 'sexp)))


 (put 'hex-number 'thing-at-point     'tap-number-at-point-hex)
 (put 'hex-number 'tap-thing-at-point 'tap-number-at-point-hex)

 (defalias 'hex-number-at-point 'tap-number-at-point-hex)
 (defun tap-number-at-point-hex ()
   "Return the number represented by the hex numeral at point.
 Return nil if none is found."
   (let ((strg  (tap-thing-at-point 'sexp)))
     (and (stringp strg)
          (tap-string-match-p "\\`[0-9a-fA-F]+\\'" strg)
          (string-to-number strg 16))))


 (when (fboundp 'syntax-ppss)            ; Based loosely on `comint-extract-string'.

   (put 'string 'bounds-of-thing-at-point     'tap-bounds-of-string-at-point)
   (put 'string 'tap-bounds-of-thing-at-point 'tap-bounds-of-string-at-point)

   (defun tap-bounds-of-string-at-point ()
     "Return the start and end locations for the string at point.
 Return a consp (START . END), where START /= END.
 Return nil if no string is found at point.

 NOTE: The ENCLOSING `\"' CHARACTERS ARE COUNTED - they are part of the
 string syntax.  See `tap-string-at-point'."
     (save-excursion
       (let (syntax beg end)
         (if (not (eq ?\" (char-after)))
             (setq syntax  (syntax-ppss))
           (or (progn (forward-char)  (setq syntax  (syntax-ppss))  (nth 3 syntax))
               (progn (backward-char) (setq syntax  (syntax-ppss))  (nth 3 syntax))))
         (and (nth 3 syntax)
              (condition-case ()
                  (setq beg  (nth 8 syntax)
			end  (progn (goto-char (nth 8 syntax)) (forward-sexp) (point)))
		(error nil))
              (cons beg end)))))

   (put 'string 'thing-at-point     'tap-string-at-point)
   (put 'string 'tap-thing-at-point 'tap-string-at-point)

   (defun tap-string-at-point ()
     "Return the string at point, or nil if there is no string at point.
 Put roughly, there is a string at point if point is on or after a \"
 and on or before a second \".

 NOTE: The text returned as a string INCLUDES THE ENCLOSING `\"' chars,
 which are part of the string syntax (the string THING).  If the result
 is read, then the string contents, i.e., the text without the
 delimiting `\"' chars, is returned from that reading.  You can obtain
 those string contents directly using `tap-string-contents-at-point'."
     (let ((bounds  (tap-bounds-of-string-at-point)))
       (and bounds  (buffer-substring (car bounds) (cdr bounds)))))

   (defun tap-string-nearest-point ()
     "Return the string nearest point, or nil if there is none.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.
 See `tap-string-at-point'."
     (tap-thing-nearest-point 'string))

   (defun tap-bounds-of-string-contents-at-point ()
     "Return the start and end locations for the string contents at point.
 Same as `tap-bounds-of-string-at-point', except that this does not
 include the enclosing `\"' characters."
     (let ((full  (tap-bounds-of-string-at-point)))
       (and full  (cons (1+ (car full)) (1- (cdr full))))))

   ;; Add this so that, for example, `thgcmd-defined-thing-p' in
   ;; `thing-cmds.el' recognizes `string-contents' as a THING.
   (put 'string-contents 'bounds-of-thing-at-point 'tap-bounds-of-string-contents-at-point)

   (defun tap-string-contents-at-point ()
     "Return the contents of the string at point, or nil if none.
 Same as `tap-string-at-point', except that this does not include the
 enclosing `\"' characters."
     (let ((bounds  (tap-bounds-of-string-contents-at-point)))
       (and bounds  (buffer-substring (car bounds) (cdr bounds)))))

   (defun tap-string-contents-nearest-point ()
     "Return the contents of the string nearest point, or nil if none.
 \"Nearest\" to point is determined as for `tap-thing-nearest-point'.
 See `tap-string-contents-at-point'."
     (let ((full  (tap-bounds-of-thing-nearest-point 'string)))
       (and full  (buffer-substring (1+ (car full)) (1- (cdr full)))))))
 
 ;;; COMMANDS ---------------------------------------------------------


 ;; This REPLACES ORIGINAL definitions in `thingatpt.el'.
 ;;
 ;;;###autoload
 (defun tap-put-thing-at-point-props ()
   "Change `(bounds-of-)thing-at-point' properties for standard things.
 This makes some things normally handled by `thingatpt.el' be handled
 instead by functions defined in `thingatpt+.el'.

 This also affects some things that are handled by `thingatpt.el' in
 another way, not by setting these properties."
   (interactive)

   ;; This one is set in `thingatpt.el'.
   (put 'list   'bounds-of-thing-at-point 'tap-bounds-of-list-at-point)

   ;; These are not set in `thingatpt.el', but a function for the THING is defined there.
   (put 'list   'thing-at-point           'tap-list-at-point)
   (put 'number 'thing-at-point           'number-at-point) ; In vanilla after 2012-10-12.
   (put 'number 'bounds-of-thing-at-point 'tap-bounds-of-number-at-point)
   t)                                    ; Return non-nil so can use with `and' etc.

 ;;;###autoload
 (defun tap-redefine-std-fns ()
   "Redefine some standard `thingatpt.el' functions, to fix them.
 The standard functions replaced are these:
  `bounds-of-thing-at-point' - Better behavior.
                               Accept optional arg SYNTAX-TABLE.
  `form-at-point'            - Accept optional arg SYNTAX-TABLE.
  `list-at-point'            - Better behavior.
                               Accept optional arg SYNTAX-TABLE.
  `symbol-at-point'          - Use `emacs-lisp-mode-syntax-table'.
  `thing-at-point'           - Ensure it returns a string or nil.
                               Accept optional arg SYNTAX-TABLE.
  `thing-at-point-bounds-of-list-at-point'
                             - Better behavior.  Accept optional
                               args UP and UNQUOTEDP."
   (interactive)

   ;; REPLACE ORIGINAL in `thingatpt.el'.
   ;;
   ;; 1. Fix Emacs bug #8667 (do not return an empty thing).
   ;; 2. Add optional argument SYNTAX-TABLE.
   ;;
   ;; NOTE: All of the other functions here are based on this function.
   ;;
   (defalias 'bounds-of-thing-at-point 'tap-bounds-of-thing-at-point)

   ;; REPLACE ORIGINAL in `thingatpt.el'.
   ;;
   ;; Add optional argument SYNTAX-TABLE.
   ;;
   (defalias 'form-at-point 'tap-form-at-point)

   ;; REPLACE ORIGINAL defined in `thingatpt.el'.
   ;;
   ;; 1. Added optional arg UP.
   ;; 2. Better, consistent behavior.
   ;; 3. Let `tap-bounds-of-thing-at-point' do its job.
   ;;
   (defalias 'list-at-point 'tap-list-at-point)

   ;; REPLACE ORIGINAL in `thingatpt.el':
   ;;
   ;; Original defn: (defun symbol-at-point () (form-at-point 'sexp 'symbolp))
   ;; With point on toto in "`toto'" (in Emacs Lisp mode), that definition
   ;; returned `toto, not toto.  With point on toto in "`toto'," (note comma),
   ;; that definition returned nil.  The definition here returns toto in both
   ;; of these cases.
   ;;
   ;; Note also that (form-at-point 'symbol) would not be a satisfactory
   ;; definition either, because it does not ensure that the symbol syntax
   ;; really represents an interned symbol.
   ;;
   (defalias 'symbol-at-point 'tap-symbol-at-point)

   ;; REPLACE ORIGINAL in `thingatpt.el'.
   ;;
   ;; Add optional argument SYNTAX-TABLE.
   ;;
   (defalias 'thing-at-point 'tap-thing-at-point)

   ;; REPLACE ORIGINAL in `thingatpt.el'.
   ;;
   ;; Better behavior.
   ;; Accept optional args UP and UNQUOTEDP.
   ;;
   (when (fboundp 'thing-at-point-bounds-of-list-at-point)
     (defalias 'thing-at-point-bounds-of-list-at-point 'tap-bounds-of-list-at-point))
   t)                                    ; Return non-nil so can use with `and' etc.

 (defun tap-define-aliases-wo-prefix ()
   "Provide aliases for `tap-' functions and variables, without prefix."
   (defalias 'bounds-of-form-at-point 'tap-bounds-of-form-at-point)
   (defalias 'bounds-of-form-nearest-point 'tap-bounds-of-form-nearest-point)
   (defalias 'bounds-of-list-nearest-point 'tap-bounds-of-list-nearest-point)
   (defalias 'bounds-of-sexp-at-point 'tap-bounds-of-sexp-at-point)
   (defalias 'bounds-of-sexp-nearest-point 'tap-bounds-of-sexp-nearest-point)
   (when (fboundp 'tap-bounds-of-string-at-point)
     (defalias 'bounds-of-string-at-point 'tap-bounds-of-string-at-point)
     (defalias 'bounds-of-string-contents-at-point 'tap-bounds-of-string-contents-at-point))
   (defalias 'bounds-of-symbol-at-point 'tap-bounds-of-symbol-at-point)
   (defalias 'bounds-of-symbol-nearest-point 'tap-bounds-of-symbol-nearest-point)
   (defalias 'bounds-of-thing-nearest-point 'tap-bounds-of-thing-nearest-point)
   (defalias 'form-at-point-with-bounds 'tap-form-at-point-with-bounds)
   (defalias 'form-nearest-point 'tap-form-nearest-point)
   (defalias 'form-nearest-point-with-bounds 'tap-form-nearest-point-with-bounds)
   (defalias 'list-at/nearest-point-with-bounds 'tap-list-at/nearest-point-with-bounds)
   (defalias 'list-at-point-with-bounds 'tap-list-at-point-with-bounds)
   (defalias 'list-nearest-point 'tap-list-nearest-point)
   (defalias 'list-nearest-point-with-bounds 'tap-list-nearest-point-with-bounds)
   (defalias 'list-nearest-point-as-string 'tap-list-nearest-point-as-string)
   (defalias 'non-nil-symbol-name-at-point 'tap-non-nil-symbol-name-at-point)
   (defalias 'non-nil-symbol-name-nearest-point 'tap-non-nil-symbol-name-nearest-point)
   (defalias 'non-nil-symbol-nearest-point 'tap-non-nil-symbol-nearest-point)
   (defalias 'number-at-point-decimal 'tap-number-at-point-decimal)
   (defalias 'number-at-point-hex 'tap-number-at-point-hex)
   (defalias 'number-nearest-point 'tap-number-nearest-point)
   (defalias 'region-or-word-at-point 'tap-region-or-word-at-point)
   (defalias 'region-or-word-nearest-point 'tap-region-or-word-nearest-point)
   (defalias 'region-or-non-nil-symbol-name-nearest-point
       'tap-region-or-non-nil-symbol-name-nearest-point)
   (defalias 'sentence-nearest-point 'tap-sentence-nearest-point)
   (defalias 'sexp-at-point-with-bounds 'tap-sexp-at-point-with-bounds)
   (defalias 'sexp-nearest-point 'tap-sexp-nearest-point)
   (defalias 'sexp-nearest-point-with-bounds 'tap-sexp-nearest-point-with-bounds)
   (when (fboundp 'tap-string-at-point)
     (defalias 'string-at-point 'tap-string-at-point)
     (defalias 'string-contents-at-point 'tap-string-contents-at-point))
   (when (fboundp 'tap-string-nearest-point)
     (defalias 'string-nearest-point 'tap-string-nearest-point)
     (defalias 'string-contents-nearest-point 'tap-string-contents-nearest-point))
   (defalias 'symbol-at-point-with-bounds 'tap-symbol-at-point-with-bounds)
   (defalias 'symbol-name-at-point 'tap-symbol-name-at-point)
   (defalias 'symbol-name-nearest-point 'tap-symbol-name-nearest-point)
   (defalias 'symbol-nearest-point 'tap-symbol-nearest-point)
   (defalias 'symbol-nearest-point-with-bounds 'tap-symbol-nearest-point-with-bounds)
   (defalias 'thing-at-point-with-bounds 'tap-thing-at-point-with-bounds)
   (defalias 'thing/form-nearest-point-with-bounds 'tap-thing/form-nearest-point-with-bounds)
   (defalias 'thing-nearest-point 'tap-thing-nearest-point)
   (defalias 'thing-nearest-point-with-bounds 'tap-thing-nearest-point-with-bounds)
   (defalias 'unquoted-list-at-point 'tap-unquoted-list-at-point)
   (defalias 'unquoted-list-nearest-point 'tap-unquoted-list-nearest-point)
   (defalias 'unquoted-list-nearest-point-as-string 'tap-unquoted-list-nearest-point-as-string)
   (defalias 'word-nearest-point 'tap-word-nearest-point)
   (when (fboundp 'tap-color-at-point)
     (defalias 'color-at-point                  'tap-color-at-point)
     (defalias 'bounds-of-color-at-point        'tap-bounds-of-color-at-point)
     (defalias 'color-nearest-point             'tap-color-nearest-point)
     (defalias 'color-nearest-point-with-bounds 'tap-color-nearest-point-with-bounds))

   (when (fboundp 'defvaralias)          ; Emacs 22+
     (defvaralias 'near-point-x-distance 'tap-near-point-x-distance)
     (defvaralias 'near-point-y-distance 'tap-near-point-y-distance))
   t)                                    ; Return non-nil so can use with `and' etc.

 ;;;###autoload
 ;; This `intern' is in order to have the symbol, e.g., for `thing-types' in `thing-cmds.el'.
 (intern "whitespace-&-newlines")
 (defun forward-whitespace-&-newlines (arg)
   "Move forward over contiguous whitespace to non-whitespace.
 Unlike `forward-whitespace', this moves over multiple contiguous
 newlines."
   (interactive "p")
   (if (natnump arg)
       (re-search-forward "[ \t]+\\|\n+" nil 'move arg)
     (while (< arg 0)
       (when (re-search-backward "[ \t]+\\|\n+" nil 'move)  (skip-chars-backward " \t\n"))
       (setq arg  (1+ arg)))))

 ;; Copied from `misc-cmds.el'.
 (intern "char-same-line") ; To have the symbol, e.g., for `thing-types' in `thing-cmds.el'.
 (unless (fboundp 'forward-char-same-line)
   (defun forward-char-same-line (&optional arg)
     "Move forward a max of ARG chars on the same line, or backward if ARG < 0.
 Return the signed number of chars moved if /= ARG, else return nil."
     (interactive "p")
     (let* ((start                      (point))
            (fwd-p                      (natnump arg))
            (inhibit-field-text-motion  t) ; Just to be sure, for end-of-line.
            (max                        (save-excursion
                                          (if fwd-p (end-of-line) (beginning-of-line))
                                          (- (point) start))))
       (forward-char (if fwd-p (min max arg) (max max arg)))
       (and (< (abs max) (abs arg))
            max))))

 ;; Inspired by `find-thing-at-point' at `https://www.emacswiki.org/emacs/SeanO'.
 ;;;###autoload
 (defun find-fn-or-var-nearest-point (&optional confirmp)
   "Go to the definition of the function or variable nearest the cursor.
 With a prefix arg, or if no function or variable is near the cursor,
 prompt for the function or variable to find, instead.

 \"Nearest\" is determined as for `tap-thing-nearest-point'.
 The search is bounded by options `tap-near-point-x-distance' and
 `tap-near-point-y-distance'."
   (interactive "P")
   (let* ((symb  (tap-symbol-nearest-point))
          (var   (and (boundp symb)  symb))
          (fn    (or (and (fboundp symb)  symb)
                     (function-called-at-point))))
     (condition-case nil
         (progn (push-mark nil t)
		(cond ((or confirmp  (not (or var fn)))
                       (when (not (or var  fn))
                         (message "Symbol nearest cursor is not a function or variable")
                         (sit-for 1))
                       (call-interactively
			(if (y-or-n-p "Find function? (n means find variable) ")
                            'find-function
                          'find-variable)))
                      (var (find-variable var))
                      ((and (fboundp 'help-C-file-name) ; Emacs 22
                            fn  (subrp (symbol-function fn)))
                       (let ((buf+pos  (find-function-search-for-symbol
					fn nil (help-C-file-name (symbol-function fn) 'subr))))
                         (when (car buf+pos) (pop-to-buffer (car buf+pos)))))
                      (fn (find-function fn))
                      (t (call-interactively 'find-function))))
       (quit (pop-mark)))))

 ;;;;;;;;;;;;;;;;;;;;;;;

 (provide 'thingatpt+)

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;; thingatpt+.el ends here

 #+END_SRC
*** COMMENT tsa-dired.el
 Dired customizations. This file is not loaded, though
**** dired other-buffer default
 Open files in the other buffer by default

  #+BEGIN_SRC elisp :tangle lisp/tsa-dired.el
    (add-hook 'dired-mode-hook
     (lambda ()
      (define-key dired-mode-map (kbd "<return>")
	'dired-find-alternate-file) ; was dired-advertised-find-file
      (define-key dired-mode-map (kbd "^")
	(lambda () (interactive) (find-alternate-file "..")))))
 #+END_SRC

**** dired shell command guessing
 http://www.gnu.org/software/emacs/manual/html_node/dired-x/Shell-Command-Guessing.html

 Always use xdg-open as the default guess in dired to open a file. 

 #+BEGIN_SRC elisp :tangle lisp/tsa-dired.el
  (setq dired-guess-shell-alist-user
	(list
	 (list "\\.*$" "xdg-open")))
 #+END_SRC

**** Unzip in dired
 #+BEGIN_SRC elisp :tangle lisp/tsa-dired.el
  (eval-after-load "dired-aux"
     '(add-to-list 'dired-compress-file-suffixes 
                   '("\\.zip\\'" ".zip" "unzip")))
 #+END_SRC

**** Edit and read-only 
 #+BEGIN_SRC elisp :tangle lisp/tsa-dired.el
  ;; read-only dired key
  (eval-after-load 'dired
    '(define-key dired-mode-map "\C-c\C-r" 'dired-toggle-read-only))
 #+END_SRC

**** Zip and unzip
 #+BEGIN_SRC elisp :tangle lisp/tsa-dired.el
  ;; use "z" to zip marked files into one .zip
  (eval-after-load "dired"
    '(define-key dired-mode-map "z" 'dired-zip-files))
  (defun dired-zip-files (zip-file)
    "Create an archive containing the marked files."
    (interactive "Enter name of zip file: ")

    ;; create the zip file
    (let ((zip-file (if (string-match ".zip$" zip-file) zip-file (concat zip-file ".zip"))))
      (shell-command 
       (concat "zip " 
               zip-file
               " "
               (concat-string-list 
		(mapcar
		 #'(lambda (filename)
                    (file-name-nondirectory filename))
		 (dired-get-marked-files))))))

    (revert-buffer)

    ;; remove the mark on all the files  "*" to " "
    ;; (dired-change-marks 42 ?\040)
    ;; mark zip file
    ;; (dired-mark-files-regexp (filename-to-regexp zip-file))
    )

  (defun concat-string-list (list) 
     "Return a string which is a concatenation of all elements of the list separated by spaces" 
      (mapconcat #'(lambda (obj) (format "%s" obj)) list " "))

  (put 'dired-find-alternate-file 'disabled nil)

  ;;; * Emacs Maintenance & Defaults
  ;; Delete to trash
  (setq delete-by-moving-to-trash t)

  ;;; dired-fixups.el --- fixups for dired mode

  ;; Author: Dino Chiesa
  ;; Created: Sat, 31 Mar 2012  10:31
  ;; Version: 0.1
  ;;

  (require 'ls-lisp)

      ;; (defun ls-lisp-format-time (file-attr time-index now)
      ;;   "################")

  (defun ls-lisp-format-file-size (file-size human-readable)
    "This is a redefinition of the function from `dired.el'. This
  fixes the formatting of file sizes in dired mode, to support very
  large files. Without this change, dired supports 8 digits max,
  which is up to 10gb.  Some files are larger than that.
  "
    (if (or (not human-readable)
            (< file-size 1024))
	(format (if (floatp file-size) " %11.0f" " %11d") file-size)
      (do ((file-size (/ file-size 1024.0) (/ file-size 1024.0))
           ;; kilo, mega, giga, tera, peta, exa
           (post-fixes (list "k" "M" "G" "T" "P" "E") (cdr post-fixes)))
          ((< file-size 1024) (format " %10.0f%s"  file-size (car post-fixes))))))


  (defun dired-sort-toggle ()
    "This is a redefinition of the fn from dired.el. Normally,
  dired sorts on either name or time, and you can swap between them
  with the s key.  This function one sets sorting on name, size,
  time, and extension. Cycling works the same.
  "
    (setq dired-actual-switches
          (let (case-fold-search)
            (cond
             ((string-match " " dired-actual-switches) ;; contains a space
              ;; New toggle scheme: add/remove a trailing " -t" " -S",
              ;; or " -U"
              ;; -t = sort by time (date)
              ;; -S = sort by size
              ;; -X = sort by extension

              (cond

               ((string-match " -t\\'" dired-actual-switches)
		(concat
		 (substring dired-actual-switches 0 (match-beginning 0))
		 " -X"))

               ((string-match " -X\\'" dired-actual-switches)
		(concat
		 (substring dired-actual-switches 0 (match-beginning 0))
		 " -S"))

               ((string-match " -S\\'" dired-actual-switches)
		(substring dired-actual-switches 0 (match-beginning 0)))

               (t
		(concat dired-actual-switches " -t"))))

             (t
              ;; old toggle scheme: look for a sorting switch, one of [tUXS]
              ;; and switch between them. Assume there is only ONE present.
              (let* ((old-sorting-switch
                      (if (string-match (concat "[t" dired-ls-sorting-switches "]")
					dired-actual-switches)
                          (substring dired-actual-switches (match-beginning 0)
                                     (match-end 0))
			""))

                     (new-sorting-switch
                      (cond
                       ((string= old-sorting-switch "t") "X")
                       ((string= old-sorting-switch "X") "S")
                       ((string= old-sorting-switch "S") "")
                       (t "t"))))
		(concat
		 "-l"
		 ;; strip -l and any sorting switches
		 (dired-replace-in-string (concat "[-lt"
                                                  dired-ls-sorting-switches "]")
                                          ""
                                          dired-actual-switches)
		 new-sorting-switch))))))

    (dired-sort-set-modeline)
    (revert-buffer))


  (defun dired-sort-set-modeline ()
   "This is a redefinition of the fn from `dired.el'. This one
  properly provides the modeline in dired mode, supporting the new
  search modes defined in the new `dired-sort-toggle'.
  "
    ;; Set modeline display according to dired-actual-switches.
    ;; Modeline display of "by name" or "by date" guarantees the user a
    ;; match with the corresponding regexps.  Non-matching switches are
    ;; shown literally.
    (when (eq major-mode 'dired-mode)
      (setq mode-name
            (let (case-fold-search)
              (cond ((string-match "^-[^t]*t[^t]*$" dired-actual-switches)
                     "Dired by time")
                    ((string-match "^-[^X]*X[^X]*$" dired-actual-switches)
                     "Dired by ext")
                    ((string-match "^-[^S]*S[^S]*$" dired-actual-switches)
                     "Dired by sz")
                    ((string-match "^-[^SXUt]*$" dired-actual-switches)
                     "Dired by name")
                    (t
                     (concat "Dired " dired-actual-switches)))))
      (force-mode-line-update)))


  (provide 'dired-fixups)

  ;;; dired-fixups.el ends here

  ;; See human-readable sizes
  (setq dired-listing-switches "-alh")

  #+END_SRC
*** TODO tsa-erc.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-erc.el

 #+END_SRC
*** TODO tsa-god-mode.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-god-mode.el

 #+END_SRC
*** TODO tsa-helm-bookmark.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-helm-bookmark.el

 #+END_SRC
*** TODO COMMENT tsa-helm.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-helm.el
   '(helm-completion-style 'emacs)
   '(helm-external-programs-associations
     '(("wav" . "xdg-open")
       ("svg" . "inkscape")
       ("jpg" . "gwenview")
       ("gif" . "gwenview")
       ("DOCX" . "loffice")
       ("ods" . "xdg-open")
       ("doc" . "xdg-open")
       ("docx" . "xdg-open")
       ("png" . "okular")
       ("xlsx" . "xdg-open")
       ("csv" . "localc")
       ("pptx" . "loffice")
       ("htm" . "firefox")
       ("mp4" . "dragon")
       ("odt" . "loffice")
       ("xcf" . "gimp")
       ("html" . "firefox")))
   '(helm-follow-input-idle-delay 0.5 t)
   '(helm-follow-mode-persistent nil)
   '(helm-mode nil)
   '(helm-source-names-using-follow
     '("Buffers"
       #("argv: /usr/bin/rg --smart-case --color=ansi --colors=match:fg:red --colors=match:style:bold \\-07-07" 6 17
	 (face helm-rg-base-rg-cmd-face)
	 18 30
	 (face helm-rg-active-arg-face)
	 31 43
	 (face helm-rg-inactive-arg-face)
	 44 65
	 (face helm-rg-inactive-arg-face)
	 66 91
	 (face helm-rg-inactive-arg-face)
	 92 99
	 (face font-lock-string-face))
       "Org Headings" "Grep" "Occur"))
   '(helm-top-poll-mode t)

 #+END_SRC
*** TODO tsa-ibuffer.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-ibuffer.el

 #+END_SRC

*** TODO tsa-org-cal.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-org-cal.el

 #+END_SRC

*** TODO tsa-org-html.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-org-html.el

 #+END_SRC
*** TODO tsa-projectile.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-projectile.el

 #+END_SRC
*** TODO tsa-tex.el
 #+BEGIN_SRC elisp :tangle lisp/tsa-tex.el

 #+END_SRC



